import { LangVariant, processor, } from 'sh-syntax';
export { languages } from './languages.js';
export class ShSyntaxParseError extends SyntaxError {
    constructor(err) {
        const error = err;
        super(('Text' in error && error.Text) || error.message);
        this.cause = err;
        if ('Pos' in error && error.Pos != null && typeof error.Pos === 'object') {
            this.loc = { start: { column: error.Pos.Col, line: error.Pos.Line } };
        }
    }
}
function hasPragma(text) {
    const commentLineRegex = /^\s*(#(?<comment>.*))?$/gm;
    let lastIndex = -1;
    for (;;) {
        const match = commentLineRegex.exec(text);
        if (match == null || match.index !== lastIndex + 1) {
            return false;
        }
        lastIndex = commentLineRegex.lastIndex;
        const comment = match.groups?.comment?.trim();
        if (comment == null) {
            continue;
        }
        if (comment.startsWith('@prettier') || comment.startsWith('@format')) {
            return true;
        }
    }
}
const dockerfileParser = {
    astFormat: 'dockerfile',
    hasPragma,
    parse: text => text,
    locStart: () => 0,
    locEnd: node => node.length,
};
let formatDockerfileContents_;
const getFormatDockerfileContents = async () => {
    if (!formatDockerfileContents_) {
        const dockerfmt = await import('@reteps/dockerfmt');
        formatDockerfileContents_ = dockerfmt.formatDockerfileContents;
    }
    return formatDockerfileContents_;
};
const dockerPrinter = {
    async print(path, { filepath, keepComments = true, variant, stopAt, recoverErrors, useTabs, tabWidth, indent = useTabs ? 0 : (tabWidth ?? 2), binaryNextLine = true, switchCaseIndent = true, spaceRedirects, keepPadding, minify, singleLine, functionNextLine, }) {
        const formatDockerfileContents = await getFormatDockerfileContents();
        try {
            return await formatDockerfileContents(path.node, {
                indent,
                spaceRedirects: spaceRedirects ?? false,
                trailingNewline: true,
            });
        }
        catch {
            return processor(path.node, {
                print: true,
                filepath,
                keepComments,
                variant,
                stopAt,
                recoverErrors,
                useTabs,
                tabWidth,
                indent,
                binaryNextLine,
                switchCaseIndent,
                spaceRedirects: spaceRedirects ?? true,
                keepPadding,
                minify,
                singleLine,
                functionNextLine,
            });
        }
    },
};
const shParser = {
    astFormat: 'sh',
    hasPragma,
    locStart: node => node.Pos.Offset,
    locEnd: node => node.End.Offset,
    async parse(text, { filepath, keepComments = true, variant, stopAt, recoverErrors, }) {
        return processor(text, {
            filepath,
            keepComments,
            variant,
            stopAt,
            recoverErrors,
        });
    },
};
const shPrinter = {
    async print(path, { originalText, filepath, keepComments = true, variant, stopAt, recoverErrors, useTabs, tabWidth, indent = useTabs ? 0 : tabWidth, binaryNextLine = true, switchCaseIndent = true, spaceRedirects = true, keepPadding, minify, singleLine, functionNextLine, }) {
        return processor(path.node, {
            originalText,
            filepath,
            keepComments,
            variant,
            stopAt,
            recoverErrors,
            useTabs,
            tabWidth,
            indent,
            binaryNextLine,
            switchCaseIndent,
            spaceRedirects,
            keepPadding,
            minify,
            singleLine,
            functionNextLine,
        });
    },
};
export const parsers = {
    dockerfile: dockerfileParser,
    sh: shParser,
};
export const printers = {
    dockerfile: dockerPrinter,
    sh: shPrinter,
};
export const options = {
    keepComments: {
        category: 'Output',
        type: 'boolean',
        default: true,
        description: 'KeepComments makes the parser parse comments and attach them to nodes, as opposed to discarding them.',
    },
    variant: {
        category: 'Config',
        type: 'choice',
        choices: [
            {
                value: LangVariant.LangBash,
                description: [
                    'LangBash corresponds to the GNU Bash language, as described in its manual at https://www.gnu.org/software/bash/manual/bash.html.',
                    '',
                    'We currently follow Bash version 5.2.',
                    '',
                    'Its string representation is "bash".',
                ].join('\n'),
            },
            {
                value: LangVariant.LangPOSIX,
                description: [
                    'LangPOSIX corresponds to the POSIX Shell language, as described at https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html.',
                    '',
                    'Its string representation is "posix" or "sh".',
                ].join('\n'),
            },
            {
                value: LangVariant.LangMirBSDKorn,
                description: [
                    'LangMirBSDKorn corresponds to the MirBSD Korn Shell, also known as mksh, as described at http://www.mirbsd.org/htman/i386/man1/mksh.htm.',
                    'Note that it shares some features with Bash, due to the shared ancestry that is ksh.',
                    '',
                    'We currently follow mksh version 59.',
                    '',
                    'Its string representation is "mksh".',
                ].join('\n'),
            },
            {
                value: LangVariant.LangBats,
                description: [
                    'LangBats corresponds to the Bash Automated Testing System language, as described at https://github.com/bats-core/bats-core.',
                    "Note that it's just a small extension of the Bash language.",
                    '',
                    'Its string representation is "bats".',
                ].join('\n'),
            },
            {
                value: LangVariant.LangAuto,
                description: [
                    "LangAuto corresponds to automatic language detection, commonly used by end-user applications like shfmt, which can guess a file's language variant given its filename or shebang.",
                    '',
                    'At this time, [Variant] does not support LangAuto.',
                ].join('\n'),
            },
        ],
        description: 'Variant changes the shell language variant that the parser will accept.',
    },
    stopAt: {
        category: 'Config',
        type: 'path',
        description: [
            'StopAt configures the lexer to stop at an arbitrary word, treating it as if it were the end of the input. It can contain any characters except whitespace, and cannot be over four bytes in size.',
            'This can be useful to embed shell code within another language, as one can use a special word to mark the delimiters between the two.',
            'As a word, it will only apply when following whitespace or a separating token. For example, StopAt("$$") will act on the inputs "foo $$" and "foo;$$", but not on "foo \'$$\'".',
            'The match is done by prefix, so the example above will also act on "foo $$bar".',
        ].join('\n'),
    },
    recoverErrors: {
        category: 'Config',
        type: 'path',
        description: [
            'RecoverErrors allows the parser to skip up to a maximum number of errors in the given input on a best-effort basis.',
            'This can be useful to tab-complete an interactive shell prompt, or when providing diagnostics on slightly incomplete shell source.',
            '',
            'Currently, this only helps with mandatory tokens from the shell grammar which are not present in the input. They result in position fields or nodes whose position report [Pos.IsRecovered] as true.',
            '',
            'For example, given the input `(foo |`, the result will contain two recovered positions; first, the pipe requires a statement to follow, and as [Stmt.Pos] reports, the entire node is recovered.',
            'Second, the subshell needs to be closed, so [Subshell.Rparen] is recovered.',
        ].join('\n'),
    },
    indent: {
        category: 'Format',
        type: 'int',
        description: 'Indent sets the number of spaces used for indentation. If set to 0, tabs will be used instead.',
    },
    binaryNextLine: {
        category: 'Output',
        type: 'boolean',
        default: true,
        description: 'BinaryNextLine will make binary operators appear on the next line when a binary command, such as a pipe, spans multiple lines. A backslash will be used.',
    },
    switchCaseIndent: {
        category: 'Format',
        type: 'boolean',
        default: true,
        description: 'SwitchCaseIndent will make switch cases be indented. As such, switch case bodies will be two levels deeper than the switch itself.',
    },
    spaceRedirects: {
        category: 'Format',
        type: 'boolean',
        default: true,
        description: "SpaceRedirects will put a space after most redirection operators. The exceptions are '>&', '<&', '>(', and '<('.",
    },
    keepPadding: {
        category: 'Format',
        type: 'boolean',
        default: false,
        description: [
            'KeepPadding will keep most nodes and tokens in the same column that they were in the original source.',
            'This allows the user to decide how to align and pad their code with spaces.',
            '',
            'Note that this feature is best-effort and will only keep the alignment stable, so it may need some human help the first time it is run.',
        ].join('\n'),
        deprecated: [
            'This formatting option is flawed and buggy, and often does not result in what the user wants when the code gets complex enough.',
            'The next major version, v4, will remove this feature entirely.',
            'See: https://github.com/mvdan/sh/issues/658',
        ].join('\n'),
    },
    minify: {
        category: 'Output',
        type: 'boolean',
        default: false,
        description: [
            'Minify will print programs in a way to save the most bytes possible.',
            'For example, indentation and comments are skipped, and extra whitespace is avoided when possible.',
        ].join('\n'),
    },
    singleLine: {
        category: 'Format',
        type: 'boolean',
        default: false,
        description: [
            'SingleLine will attempt to print programs in one line. For example, lists of commands or nested blocks do not use newlines in this mode.',
            'Note that some newlines must still appear, such as those following comments or around here-documents.',
            '',
            "Print's trailing newline when given a [*File] is not affected by this option.",
        ].join('\n'),
    },
    functionNextLine: {
        category: 'Format',
        type: 'boolean',
        default: false,
        description: "FunctionNextLine will place a function's opening braces on the next line.",
    },
};
//# sourceMappingURL=index.js.map