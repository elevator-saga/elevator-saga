//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const node_fs_promises = __toESM(require("node:fs/promises"));
const node_path = __toESM(require("node:path"));
const node_url = __toESM(require("node:url"));
require("../vendors/wasm_exec.cjs");

//#region src/types.ts
const LangVariant = {
	LangBash: 0,
	LangPOSIX: 1,
	LangMirBSDKorn: 2,
	LangBats: 3,
	LangAuto: 4
};

//#endregion
//#region src/processor.ts
var ParseError = class extends Error {
	Filename;
	Incomplete;
	Text;
	Pos;
	constructor({ Filename, Incomplete, Text, Pos }) {
		super(Text);
		this.Filename = Filename;
		this.Incomplete = Incomplete;
		this.Text = Text;
		this.Pos = Pos;
	}
};
let encoder;
let decoder;
const getProcessor = (getWasm) => {
	let wasmBufferSource;
	let wasmBufferSourcePromise;
	encoder ??= new TextEncoder();
	decoder ??= new TextDecoder();
	/**
	* Processes a shell script input using a WebAssembly module.
	*
	* This asynchronous function accepts shell script input either as a string or
	* as an AST File, along with a set of options that control formatting, error
	* recovery, and output. It ensures that the WebAssembly module is loaded and
	* instantiated, allocates memory for the file path and text content, and then
	* calls the module's processing function with the provided options. Depending
	* on the `print` flag, it returns either the processed text or a File
	* representing the parsed AST.
	*
	* @param textOrAst - The shell script input as a string or as an AST File.
	*   When providing a non-string input and `print` is false, the
	*   `originalText` option must be supplied.
	* @param options - An object containing processing options:
	*
	*   - `filepath`: The file path associated with the input, used primarily for
	*       error reporting.
	*   - `print`: If true, the function returns the processed text; otherwise, it
	*       returns the processed AST as a File.
	*   - `originalText`: The original text of the shell script, required when
	*       `textOrAst` is not a string.
	*   - `keepComments`: Determines whether comments should be preserved in the
	*       output.
	*   - `variant`: Specifies the shell scripting variant (e.g.,
	*       {@link LangVariant.LangBash}).
	*   - `stopAt`: A token indicating where to halt further processing.
	*   - `recoverErrors`: Sets the level of error recovery during processing
	*       (default is 0).
	*   - `useTabs`, `tabWidth`, `indent`: Options to control indentation formatting.
	*   - `binaryNextLine`, `switchCaseIndent`, `spaceRedirects`, `keepPadding`,
	*       `minify`, `singleLine`, `functionNextLine`: Additional flags that
	*       influence formatting details and output structure.
	*
	* @returns A promise that resolves to either the processed text (if `print`
	*   is true) or a File (if `print` is false).
	* @throws {TypeError} If the original text is required but not provided.
	* @throws {ParseError} If the processed output is not valid JSON or indicates
	*   a parsing error.
	* @throws {SyntaxError} If a syntax error is detected without an associated
	*   parse error object.
	*/
	async function processor$1(textOrAst, { filepath, print: print$1 = false, originalText, keepComments = true, variant = LangVariant.LangBash, stopAt = "", recoverErrors = 0, useTabs = false, tabWidth = 2, indent = useTabs ? 0 : tabWidth, binaryNextLine = true, switchCaseIndent = true, spaceRedirects = true, keepPadding = false, minify = false, singleLine = false, functionNextLine = false } = {}) {
		if (!wasmBufferSource && !wasmBufferSourcePromise && getWasm.length === 0) wasmBufferSourcePromise = Promise.resolve(getWasm()).then((source) => "arrayBuffer" in source ? source.arrayBuffer() : source);
		if (wasmBufferSourcePromise) wasmBufferSource = await wasmBufferSourcePromise;
		if (typeof textOrAst !== "string" && !print$1) {
			print$1 = true;
			if (originalText == null) throw new TypeError("`originalText` is required for now, hope we will find better solution later");
		}
		const go = new Go();
		const wasm = getWasm.length === 0 ? await WebAssembly.instantiate(wasmBufferSource, go.importObject) : { instance: await getWasm(go.importObject) };
		/**
		* Do not await this promise, because it only resolves once the go main()
		* function has exited. But we need the main function to stay alive to be
		* able to call the `parse` and `print` function.
		*/
		go.run(wasm.instance);
		const { memory, wasmAlloc, wasmFree, process } = wasm.instance.exports;
		const filePath = encoder.encode(filepath);
		const text = encoder.encode(originalText || textOrAst);
		const uStopAt = encoder.encode(stopAt);
		const filePathPointer = wasmAlloc(filePath.byteLength);
		new Uint8Array(memory.buffer).set(filePath, filePathPointer);
		const textPointer = wasmAlloc(text.byteLength);
		new Uint8Array(memory.buffer).set(text, textPointer);
		const stopAtPointer = wasmAlloc(uStopAt.byteLength);
		new Uint8Array(memory.buffer).set(uStopAt, stopAtPointer);
		const resultPointer = process(filePathPointer, filePath.byteLength, filePath.byteLength, textPointer, text.byteLength, text.byteLength, print$1, keepComments, variant, stopAtPointer, uStopAt.byteLength, uStopAt.byteLength, recoverErrors, indent, binaryNextLine, switchCaseIndent, spaceRedirects, keepPadding, minify, singleLine, functionNextLine);
		wasmFree(filePathPointer);
		wasmFree(textPointer);
		wasmFree(stopAtPointer);
		const result = new Uint8Array(memory.buffer).subarray(resultPointer);
		const end = result.indexOf(0);
		const string = decoder.decode(result.subarray(0, end));
		/* istanbul ignore if -- @preserve */
		if (!string.startsWith("{\"") || !string.endsWith("}")) throw new ParseError({
			Filename: filepath,
			Incomplete: true,
			Text: string
		});
		const { file, text: processedText, parseError, message } = JSON.parse(string);
		if (parseError || message)
 /* istanbul ignore next -- @preserve */
		throw parseError == null ? new SyntaxError(message) : new ParseError(parseError);
		return print$1 ? processedText : file;
	}
	return processor$1;
};

//#endregion
//#region src/index.ts
const importMetaUrl = require("url").pathToFileURL(__filename).href;
/* istanbul ignore next -- @preserve */
const _dirname = importMetaUrl ? node_path.default.dirname((0, node_url.fileURLToPath)(importMetaUrl)) : __dirname;
const processor = getProcessor(() => node_fs_promises.default.readFile(node_path.default.resolve(_dirname, "../main.wasm")));
const parse = (text, options) => processor(text, options);
function print(textOrAst, options) {
	if (typeof textOrAst === "string") return processor(textOrAst, {
		...options,
		print: true
	});
	return processor(textOrAst, options);
}

//#endregion
exports.LangVariant = LangVariant;
exports.ParseError = ParseError;
exports.getProcessor = getProcessor;
exports.parse = parse;
exports.print = print;
exports.processor = processor;