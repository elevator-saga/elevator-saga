import "../vendors/wasm_exec.cjs";

//#region src/types.d.ts
type ValueOf<T> = T[keyof T];
declare const LangVariant: {
  readonly LangBash: 0;
  readonly LangPOSIX: 1;
  readonly LangMirBSDKorn: 2;
  readonly LangBats: 3;
  readonly LangAuto: 4;
};
type LangVariant = ValueOf<typeof LangVariant>;
interface ShParserOptions {
  keepComments?: boolean;
  variant?: LangVariant;
  stopAt?: string;
  recoverErrors?: number;
}
interface ShPrinterOptions {
  indent?: number;
  binaryNextLine?: boolean;
  switchCaseIndent?: boolean;
  spaceRedirects?: boolean;
  keepPadding?: boolean;
  minify?: boolean;
  singleLine?: boolean;
  functionNextLine?: boolean;
}
interface ShSyntaxOptions extends ShParserOptions, ShPrinterOptions {}
interface ShOptions extends ShSyntaxOptions {
  filepath?: string;
  useTabs?: boolean;
  tabWidth?: number;
}
interface ShPrintOptions extends ShOptions {
  originalText: string;
}
interface Pos$1 {
  Col: number;
  Line: number;
  Offset: number;
}
interface Node {
  Pos: Pos$1;
  End: Pos$1;
}
interface Comment extends Node {
  Text: string;
}
interface Word extends Node {
  Parts: Node[];
  Lit: string;
}
interface Lit extends Node {
  ValuePos: Pos$1;
  ValueEnd: Pos$1;
  Value: string;
}
interface Redirect extends Node {
  OpPos: Pos$1;
  Op: string;
  N: Lit | null;
  Word: Word;
  Hdoc: Word | null;
}
interface Stmt extends Node {
  Comments: Comment[];
  Cmd: Node | null;
  Position: Pos$1;
  Semicolon: Pos$1;
  Negated: boolean;
  Background: boolean;
  Coprocess: boolean;
  Redirs: Redirect[];
}
interface File extends Node {
  Name: string;
  Stmts: Stmt[];
}
interface IParseError {
  Filename?: string;
  Incomplete: boolean;
  Text: string;
  Pos?: Pos$1;
} //#endregion
//#region src/processor.d.ts
declare class ParseError extends Error implements IParseError {
  Filename?: string;
  Incomplete: boolean;
  Text: string;
  Pos?: {
    Col: number;
    Line: number;
    Offset: number;
  };
  constructor({
    Filename,
    Incomplete,
    Text,
    Pos
  }: IParseError);
}
type GetWebAssemblySource = () => Buffer | BufferSource | Promise<Buffer | BufferSource | Response> | Response;
type GetWebAssemblyInstance = (imports: WebAssembly.Imports) => Promise<WebAssembly.Instance> | WebAssembly.Instance;
declare const getProcessor: (getWasm: GetWebAssemblyInstance | GetWebAssemblySource) => {
  (text: string, options?: ShOptions): Promise<File>;
  (text: string, options?: ShOptions & {
    print: true;
  }): Promise<string>;
  (ast: File, options?: ShOptions & {
    originalText: string;
  }): Promise<string>;
};

//#endregion
//#region src/index.d.ts
declare const processor: {
  (text: string, options?: ShOptions): Promise<File>;
  (text: string, options?: ShOptions & {
    print: true;
  }): Promise<string>;
  (ast: File, options?: ShOptions & {
    originalText: string;
  }): Promise<string>;
};
declare const parse: (text: string, options?: ShOptions) => Promise<File>;
declare function print(text: string, options?: ShOptions): Promise<string>;
declare function print(ast: File, options?: ShPrintOptions): Promise<string>;

//#endregion
export { Comment, File, GetWebAssemblyInstance, GetWebAssemblySource, IParseError, LangVariant, Lit, Node, ParseError, Pos$1 as Pos, Redirect, ShOptions, ShParserOptions, ShPrintOptions, ShPrinterOptions, ShSyntaxOptions, Stmt, ValueOf, Word, getProcessor, parse, print, processor };