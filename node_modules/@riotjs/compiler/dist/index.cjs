/* Riot Compiler, @license MIT */
'use strict';

var riotParser = require('@riotjs/parser');
var recast = require('recast');
var compose = require('cumpa');
var checks = require('@riotjs/util/checks');
var domNodes = require('dom-nodes');
var typescript_js = require('recast/parsers/typescript.js');
var util_js = require('recast/lib/util.js');
var sourceMap = require('source-map');
var misc = require('@riotjs/util/misc');
var cssEscape = require('cssesc');
var curry = require('curri');
var util = require('@riotjs/util');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var riotParser__default = /*#__PURE__*/_interopDefault(riotParser);
var compose__default = /*#__PURE__*/_interopDefault(compose);
var cssEscape__default = /*#__PURE__*/_interopDefault(cssEscape);
var curry__default = /*#__PURE__*/_interopDefault(curry);

const TAG_LOGIC_PROPERTY = 'exports';
const TAG_CSS_PROPERTY = 'css';
const TAG_TEMPLATE_PROPERTY = 'template';
const TAG_NAME_PROPERTY = 'name';
const RIOT_MODULE_ID = 'riot';
const RIOT_INTERFACE_WRAPPER_NAME = 'RiotComponentWrapper';
const RIOT_TAG_INTERFACE_NAME = 'RiotComponent';

const BINDING_TYPES = 'bindingTypes';
const EACH_BINDING_TYPE = 'EACH';
const IF_BINDING_TYPE = 'IF';
const TAG_BINDING_TYPE = 'TAG';
const SLOT_BINDING_TYPE = 'SLOT';

const EXPRESSION_TYPES = 'expressionTypes';
const ATTRIBUTE_EXPRESSION_TYPE = 'ATTRIBUTE';
const VALUE_EXPRESSION_TYPE = 'VALUE';
const REF_EXPRESSION_TYPE = 'REF';
const TEXT_EXPRESSION_TYPE = 'TEXT';
const EVENT_EXPRESSION_TYPE = 'EVENT';

const TEMPLATE_FN = 'template';
const SCOPE = '_scope';
const GET_COMPONENT_FN = 'getComponent';

// keys needed to create the DOM bindings
const BINDING_SELECTOR_KEY = 'selector';
const BINDING_GET_COMPONENT_KEY = 'getComponent';
const BINDING_TEMPLATE_KEY = 'template';
const BINDING_TYPE_KEY = 'type';
const BINDING_REDUNDANT_ATTRIBUTE_KEY = 'redundantAttribute';
const BINDING_CONDITION_KEY = 'condition';
const BINDING_ITEM_NAME_KEY = 'itemName';
const BINDING_GET_KEY_KEY = 'getKey';
const BINDING_INDEX_NAME_KEY = 'indexName';
const BINDING_EVALUATE_KEY = 'evaluate';
const BINDING_NAME_KEY = 'name';
const BINDING_SLOTS_KEY = 'slots';
const BINDING_EXPRESSIONS_KEY = 'expressions';
const BINDING_IS_BOOLEAN_ATTRIBUTE = 'isBoolean';
const BINDING_CHILD_NODE_INDEX_KEY = 'childNodeIndex';
// slots keys
const BINDING_BINDINGS_KEY = 'bindings';
const BINDING_ID_KEY = 'id';
const BINDING_HTML_KEY = 'html';
const BINDING_ATTRIBUTES_KEY = 'attributes';

// DOM directives
const IF_DIRECTIVE = 'if';
const EACH_DIRECTIVE = 'each';
const KEY_ATTRIBUTE = 'key';
const SLOT_ATTRIBUTE = 'slot';
const VALUE_ATTRIBUTE = 'value';
const REF_ATTRIBUTE = 'ref';
const NAME_ATTRIBUTE = 'name';
const IS_DIRECTIVE = 'is';

// Misc
const DEFAULT_SLOT_NAME = 'default';
const TEXT_NODE_EXPRESSION_PLACEHOLDER = ' ';
const BINDING_SELECTOR_PREFIX = 'expr';
const SLOT_TAG_NODE_NAME = 'slot';
const PROGRESS_TAG_NODE_NAME = 'progress';
const TEMPLATE_TAG_NODE_NAME = 'template';

// Riot Parser constants
riotParser.constants.IS_RAW;
const IS_VOID_NODE = riotParser.constants.IS_VOID;
const IS_CUSTOM_NODE = riotParser.constants.IS_CUSTOM;
const IS_BOOLEAN_ATTRIBUTE = riotParser.constants.IS_BOOLEAN;
const IS_SPREAD_ATTRIBUTE = riotParser.constants.IS_SPREAD;

const types = recast.types;
const builders = recast.types.builders;
const namedTypes = recast.types.namedTypes;

var builtin = {
	AggregateError: false,
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	FinalizationRegistry: false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"Intl": false,
	"isFinite": false,
	"isNaN": false,
	Iterator: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	"WeakMap": false,
	WeakRef: false,
	"WeakSet": false
};
var globals = {
	builtin: builtin};

const browserAPIs = ['window', 'document', 'console'];
const builtinAPIs = Object.keys(globals.builtin);

const isIdentifier = (n) => namedTypes.Identifier.check(n);
const isLiteral = (n) => namedTypes.Literal.check(n);
const isExpressionStatement = (n) =>
  namedTypes.ExpressionStatement.check(n);
const isThisExpression = (n) => namedTypes.ThisExpression.check(n);
const isObjectExpression = (n) => namedTypes.ObjectExpression.check(n);
const isThisExpressionStatement = (n) =>
  isExpressionStatement(n) &&
  isMemberExpression(n.expression.left) &&
  isThisExpression(n.expression.left.object);
const isNewExpression = (n) => namedTypes.NewExpression.check(n);
const isSequenceExpression = (n) =>
  namedTypes.SequenceExpression.check(n);
const isExportDefaultStatement = (n) =>
  namedTypes.ExportDefaultDeclaration.check(n);
const isMemberExpression = (n) => namedTypes.MemberExpression.check(n);
const isImportDeclaration = (n) => namedTypes.ImportDeclaration.check(n);
const isTypeAliasDeclaration = (n) =>
  namedTypes.TSTypeAliasDeclaration.check(n);
const isInterfaceDeclaration = (n) =>
  namedTypes.TSInterfaceDeclaration.check(n);
const isExportNamedDeclaration = (n) =>
  namedTypes.ExportNamedDeclaration.check(n);

const isBrowserAPI = ({ name }) => browserAPIs.includes(name);
const isBuiltinAPI = ({ name }) => builtinAPIs.includes(name);
const isRaw = (n) => n && n.raw;

/**
 * True if the node has not expression set nor bindings directives
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only if it's a static node that doesn't need bindings or expressions
 */
function isStaticNode(node) {
  return [
    hasExpressions,
    findEachAttribute,
    findIfAttribute,
    isCustomNode,
    isSlotNode,
  ].every((test) => !test(node))
}

/**
 * Check if a node should be rendered in the final component HTML
 * For example slot <template slot="content"> tags not using `each` or `if` directives can be removed
 * see also https://github.com/riot/riot/issues/2888
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if we can remove this tag from the component rendered HTML
 */
function isRemovableNode(node) {
  return (
    isTemplateNode(node) &&
    !checks.isNil(findAttribute(SLOT_ATTRIBUTE, node)) &&
    !hasEachAttribute(node) &&
    !hasIfAttribute(node)
  )
}

/**
 * Check if a node name is part of the browser or builtin javascript api or it belongs to the current scope
 * @param   { types.NodePath } path - containing the current node visited
 * @returns {boolean} true if it's a global api variable
 */
function isGlobal({ scope, node }) {
  // recursively find the identifier of this AST path
  if (node.object) {
    return isGlobal({ node: node.object, scope })
  }

  return Boolean(
    isRaw(node) ||
      isBuiltinAPI(node) ||
      isBrowserAPI(node) ||
      isNewExpression(node) ||
      isNodeInScope(scope, node),
  )
}

/**
 * Checks if the identifier of a given node exists in a scope
 * @param {Scope} scope - scope where to search for the identifier
 * @param {types.Node} node - node to search for the identifier
 * @returns {boolean} true if the node identifier is defined in the given scope
 */
function isNodeInScope(scope, node) {
  const traverse = (isInScope = false) => {
    types.visit(node, {
      visitIdentifier(path) {
        if (scope.lookup(getName(path.node))) {
          isInScope = true;
        }

        this.abort();
      },
    });

    return isInScope
  };

  return traverse()
}

/**
 * True if the node has the isCustom attribute set
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if either it's a riot component or a custom element
 */
function isCustomNode(node) {
  return !!(node[IS_CUSTOM_NODE] || hasIsAttribute(node))
}

/**
 * True the node is <slot>
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if it's a slot node
 */
function isSlotNode(node) {
  return node.name === SLOT_TAG_NODE_NAME
}

/**
 * True if the node has the isVoid attribute set
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if the node is self closing
 */
function isVoidNode(node) {
  return !!node[IS_VOID_NODE]
}

/**
 * True if the riot parser did find a tag node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the tag nodes
 */
function isTagNode(node) {
  return node.type === riotParser.nodeTypes.TAG
}

/**
 * True if the riot parser did find a text node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the text nodes
 */
function isTextNode(node) {
  return node.type === riotParser.nodeTypes.TEXT
}

/**
 * True if the node parsed any of the root nodes (each, tag bindings create root nodes as well...)
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the root nodes
 */
function isRootNode(node) {
  return node.isRoot
}

/**
 * True if the node parsed is the absolute root node (nested root nodes are not considered)
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the root nodes
 */
function isAbsoluteRootNode(node) {
  return node.isRoot && !node.isNestedRoot
}

/**
 * True if the attribute parsed is of type spread one
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true if the attribute node is of type spread
 */
function isSpreadAttribute(node) {
  return node[IS_SPREAD_ATTRIBUTE]
}

/**
 * True if the node is an attribute and its name is "value"
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for value attribute nodes
 */
function isValueAttribute(node) {
  return node.name === VALUE_ATTRIBUTE
}

/**
 * True if the node is an attribute and its name is "ref"
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for ref attribute nodes
 */
function isRefAttribute(node) {
  return node.name === REF_ATTRIBUTE
}

/**
 * True if the DOM node is a progress tag
 * @param   {RiotParser.Node}  node - riot parser node
 * @returns {boolean} true for the progress tags
 */
function isProgressNode(node) {
  return node.name === PROGRESS_TAG_NODE_NAME
}

/**
 * True if the DOM node is a <template> tag
 * @param   {RiotParser.Node}  node - riot parser node
 * @returns {boolean} true for the progress tags
 */
function isTemplateNode(node) {
  return node.name === TEMPLATE_TAG_NODE_NAME
}

/**
 * True if the node is an attribute and a DOM handler
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for dom listener attribute nodes
 */
const isEventAttribute = (() => {
  const EVENT_ATTR_RE = /^on/;
  return (node) => EVENT_ATTR_RE.test(node.name)
})();

/**
 * Check if a string is an html comment
 * @param   {string}  string - test string
 * @returns {boolean} true if html comment
 */
function isCommentString(string) {
  return string.trim().indexOf('<!') === 0
}

/**
 * True if the node has expressions or expression attributes
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} ditto
 */
function hasExpressions(node) {
  return !!(
    node.expressions ||
    // has expression attributes
    getNodeAttributes(node).some((attribute) => hasExpressions(attribute)) ||
    // has child text nodes with expressions
    (node.nodes &&
      node.nodes.some((node) => isTextNode(node) && hasExpressions(node)))
  )
}

/**
 * True if the node is a directive having its own template or it's a slot node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {boolean} true only for the IF EACH and TAG bindings or it's a slot node
 */
function hasItsOwnTemplate(node) {
  return [findEachAttribute, findIfAttribute, isCustomNode, isSlotNode].some(
    (test) => test(node),
  )
}

const hasIfAttribute = compose__default.default(Boolean, findIfAttribute);
const hasEachAttribute = compose__default.default(Boolean, findEachAttribute);
const hasIsAttribute = compose__default.default(Boolean, findIsAttribute);
compose__default.default(Boolean, findKeyAttribute);
const hasChildrenNodes = (node) => node?.nodes?.length > 0;

/**
 * Find the attribute node
 * @param   { string } name -  name of the attribute we want to find
 * @param   { riotParser.nodeTypes.TAG } node - a tag node
 * @returns { riotParser.nodeTypes.ATTR } attribute node
 */
function findAttribute(name, node) {
  return (
    node.attributes && node.attributes.find((attr) => getName(attr) === name)
  )
}

function findIfAttribute(node) {
  return findAttribute(IF_DIRECTIVE, node)
}

function findEachAttribute(node) {
  return findAttribute(EACH_DIRECTIVE, node)
}

function findKeyAttribute(node) {
  return findAttribute(KEY_ATTRIBUTE, node)
}

function findIsAttribute(node) {
  return findAttribute(IS_DIRECTIVE, node)
}

/**
 * Find all the node attributes that are not expressions
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array} list of all the static attributes
 */
function findStaticAttributes(node) {
  return getNodeAttributes(node).filter(
    (attribute) => !hasExpressions(attribute),
  )
}

/**
 * Find all the node attributes that have expressions
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array} list of all the dynamic attributes
 */
function findDynamicAttributes(node) {
  return getNodeAttributes(node).filter(hasExpressions)
}

function nullNode() {
  return builders.literal(null)
}

function simplePropertyNode(key, value) {
  const property = builders.property(
    'init',
    builders.identifier(key),
    value,
    false,
  );

  property.sho;
  return property
}

const LINES_RE = /\r\n?|\n/g;

/**
 * Split a string into a rows array generated from its EOL matches
 * @param   { string } string [description]
 * @returns { Array } array containing all the string rows
 */
function splitStringByEOL(string) {
  return string.split(LINES_RE)
}

/**
 * Get the line and the column of a source text based on its position in the string
 * @param   { string } string - target string
 * @param   { number } position - target position
 * @returns { Object } object containing the source text line and column
 */
function getLineAndColumnByPosition(string, position) {
  const lines = splitStringByEOL(string.slice(0, position));

  return {
    line: lines.length,
    column: lines[lines.length - 1].length,
  }
}

/**
 * Add the offset to the code that must be parsed in order to generate properly the sourcemaps
 * @param {string} input - input string
 * @param {string} source - original source code
 * @param {RiotParser.Node} node - node that we are going to transform
 * @return {string} the input string with the offset properly set
 */
function addLineOffset(input, source, node) {
  const { column, line } = getLineAndColumnByPosition(source, node.start);
  return `${'\n'.repeat(line - 1)}${' '.repeat(column + 1)}${input}`
}

/**
 * Create a simple attribute expression
 * @param   {RiotParser.Node.Attr} sourceNode - the custom tag
 * @param   {RiotParser.Node} parentNode - the html node that has received the attribute expression
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {AST.Node} object containing the expression binding keys
 */
function createAttributeExpression(
  sourceNode,
  parentNode,
  sourceFile,
  sourceCode,
) {
  const isSpread = isSpreadAttribute(sourceNode);

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(ATTRIBUTE_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_IS_BOOLEAN_ATTRIBUTE,
      builders.literal(
        // the hidden attribute is always a boolean and can be applied to any DOM node
        sourceNode.name === 'hidden' ||
          // Custom nodes can't handle boolean attrs
          // Riot.js will handle the bool attrs logic only on native html tags
          (!parentNode[IS_CUSTOM_NODE] &&
            !isAbsoluteRootNode(parentNode) &&
            !isSpread &&
            !!sourceNode[IS_BOOLEAN_ATTRIBUTE]),
      ),
    ),
    simplePropertyNode(
      BINDING_NAME_KEY,
      isSpread ? nullNode() : builders.literal(sourceNode.name),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

/**
 * Create a simple event expression
 * @param   {RiotParser.Node.Attr} sourceNode - attribute containing the event handlers
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {AST.Node} object containing the expression binding keys
 */
function createEventExpression(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(EVENT_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(BINDING_NAME_KEY, builders.literal(sourceNode.name)),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

var quot = "\"";
var amp = "&";
var apos = "'";
var lt = "<";
var gt = ">";
var nbsp = " ";
var iexcl = "¡";
var cent = "¢";
var pound = "£";
var curren = "¤";
var yen = "¥";
var brvbar = "¦";
var sect = "§";
var uml = "¨";
var copy = "©";
var ordf = "ª";
var laquo = "«";
var not = "¬";
var shy = "­";
var reg = "®";
var macr = "¯";
var deg = "°";
var plusmn = "±";
var sup2 = "²";
var sup3 = "³";
var acute = "´";
var micro = "µ";
var para = "¶";
var middot = "·";
var cedil = "¸";
var sup1 = "¹";
var ordm = "º";
var raquo = "»";
var frac14 = "¼";
var frac12 = "½";
var frac34 = "¾";
var iquest = "¿";
var Agrave = "À";
var Aacute = "Á";
var Acirc = "Â";
var Atilde = "Ã";
var Auml = "Ä";
var Aring = "Å";
var AElig = "Æ";
var Ccedil = "Ç";
var Egrave = "È";
var Eacute = "É";
var Ecirc = "Ê";
var Euml = "Ë";
var Igrave = "Ì";
var Iacute = "Í";
var Icirc = "Î";
var Iuml = "Ï";
var ETH = "Ð";
var Ntilde = "Ñ";
var Ograve = "Ò";
var Oacute = "Ó";
var Ocirc = "Ô";
var Otilde = "Õ";
var Ouml = "Ö";
var times = "×";
var Oslash = "Ø";
var Ugrave = "Ù";
var Uacute = "Ú";
var Ucirc = "Û";
var Uuml = "Ü";
var Yacute = "Ý";
var THORN = "Þ";
var szlig = "ß";
var agrave = "à";
var aacute = "á";
var acirc = "â";
var atilde = "ã";
var auml = "ä";
var aring = "å";
var aelig = "æ";
var ccedil = "ç";
var egrave = "è";
var eacute = "é";
var ecirc = "ê";
var euml = "ë";
var igrave = "ì";
var iacute = "í";
var icirc = "î";
var iuml = "ï";
var eth = "ð";
var ntilde = "ñ";
var ograve = "ò";
var oacute = "ó";
var ocirc = "ô";
var otilde = "õ";
var ouml = "ö";
var divide = "÷";
var oslash = "ø";
var ugrave = "ù";
var uacute = "ú";
var ucirc = "û";
var uuml = "ü";
var yacute = "ý";
var thorn = "þ";
var yuml = "ÿ";
var OElig = "Œ";
var oelig = "œ";
var Scaron = "Š";
var scaron = "š";
var Yuml = "Ÿ";
var fnof = "ƒ";
var circ = "ˆ";
var tilde = "˜";
var Alpha = "Α";
var Beta = "Β";
var Gamma = "Γ";
var Delta = "Δ";
var Epsilon = "Ε";
var Zeta = "Ζ";
var Eta = "Η";
var Theta = "Θ";
var Iota = "Ι";
var Kappa = "Κ";
var Lambda = "Λ";
var Mu = "Μ";
var Nu = "Ν";
var Xi = "Ξ";
var Omicron = "Ο";
var Pi = "Π";
var Rho = "Ρ";
var Sigma = "Σ";
var Tau = "Τ";
var Upsilon = "Υ";
var Phi = "Φ";
var Chi = "Χ";
var Psi = "Ψ";
var Omega = "Ω";
var alpha = "α";
var beta = "β";
var gamma = "γ";
var delta = "δ";
var epsilon = "ε";
var zeta = "ζ";
var eta = "η";
var theta = "θ";
var iota = "ι";
var kappa = "κ";
var lambda = "λ";
var mu = "μ";
var nu = "ν";
var xi = "ξ";
var omicron = "ο";
var pi = "π";
var rho = "ρ";
var sigmaf = "ς";
var sigma = "σ";
var tau = "τ";
var upsilon = "υ";
var phi = "φ";
var chi = "χ";
var psi = "ψ";
var omega = "ω";
var thetasym = "ϑ";
var upsih = "ϒ";
var piv = "ϖ";
var ensp = " ";
var emsp = " ";
var thinsp = " ";
var zwnj = "‌";
var zwj = "‍";
var lrm = "‎";
var rlm = "‏";
var ndash = "–";
var mdash = "—";
var lsquo = "‘";
var rsquo = "’";
var sbquo = "‚";
var ldquo = "“";
var rdquo = "”";
var bdquo = "„";
var dagger = "†";
var Dagger = "‡";
var bull = "•";
var hellip = "…";
var permil = "‰";
var prime = "′";
var Prime = "″";
var lsaquo = "‹";
var rsaquo = "›";
var oline = "‾";
var frasl = "⁄";
var euro = "€";
var image = "ℑ";
var weierp = "℘";
var real = "ℜ";
var trade = "™";
var alefsym = "ℵ";
var larr = "←";
var uarr = "↑";
var rarr = "→";
var darr = "↓";
var harr = "↔";
var crarr = "↵";
var lArr = "⇐";
var uArr = "⇑";
var rArr = "⇒";
var dArr = "⇓";
var hArr = "⇔";
var forall = "∀";
var part = "∂";
var exist = "∃";
var empty = "∅";
var nabla = "∇";
var isin = "∈";
var notin = "∉";
var ni = "∋";
var prod = "∏";
var sum = "∑";
var minus = "−";
var lowast = "∗";
var radic = "√";
var prop = "∝";
var infin = "∞";
var ang = "∠";
var and = "∧";
var or = "∨";
var cap = "∩";
var cup = "∪";
var int = "∫";
var there4 = "∴";
var sim = "∼";
var cong = "≅";
var asymp = "≈";
var ne = "≠";
var equiv = "≡";
var le = "≤";
var ge = "≥";
var sub = "⊂";
var sup = "⊃";
var nsub = "⊄";
var sube = "⊆";
var supe = "⊇";
var oplus = "⊕";
var otimes = "⊗";
var perp = "⊥";
var sdot = "⋅";
var lceil = "⌈";
var rceil = "⌉";
var lfloor = "⌊";
var rfloor = "⌋";
var lang = "〈";
var rang = "〉";
var loz = "◊";
var spades = "♠";
var clubs = "♣";
var hearts = "♥";
var diams = "♦";
var entities = {
	quot: quot,
	amp: amp,
	apos: apos,
	lt: lt,
	gt: gt,
	nbsp: nbsp,
	iexcl: iexcl,
	cent: cent,
	pound: pound,
	curren: curren,
	yen: yen,
	brvbar: brvbar,
	sect: sect,
	uml: uml,
	copy: copy,
	ordf: ordf,
	laquo: laquo,
	not: not,
	shy: shy,
	reg: reg,
	macr: macr,
	deg: deg,
	plusmn: plusmn,
	sup2: sup2,
	sup3: sup3,
	acute: acute,
	micro: micro,
	para: para,
	middot: middot,
	cedil: cedil,
	sup1: sup1,
	ordm: ordm,
	raquo: raquo,
	frac14: frac14,
	frac12: frac12,
	frac34: frac34,
	iquest: iquest,
	Agrave: Agrave,
	Aacute: Aacute,
	Acirc: Acirc,
	Atilde: Atilde,
	Auml: Auml,
	Aring: Aring,
	AElig: AElig,
	Ccedil: Ccedil,
	Egrave: Egrave,
	Eacute: Eacute,
	Ecirc: Ecirc,
	Euml: Euml,
	Igrave: Igrave,
	Iacute: Iacute,
	Icirc: Icirc,
	Iuml: Iuml,
	ETH: ETH,
	Ntilde: Ntilde,
	Ograve: Ograve,
	Oacute: Oacute,
	Ocirc: Ocirc,
	Otilde: Otilde,
	Ouml: Ouml,
	times: times,
	Oslash: Oslash,
	Ugrave: Ugrave,
	Uacute: Uacute,
	Ucirc: Ucirc,
	Uuml: Uuml,
	Yacute: Yacute,
	THORN: THORN,
	szlig: szlig,
	agrave: agrave,
	aacute: aacute,
	acirc: acirc,
	atilde: atilde,
	auml: auml,
	aring: aring,
	aelig: aelig,
	ccedil: ccedil,
	egrave: egrave,
	eacute: eacute,
	ecirc: ecirc,
	euml: euml,
	igrave: igrave,
	iacute: iacute,
	icirc: icirc,
	iuml: iuml,
	eth: eth,
	ntilde: ntilde,
	ograve: ograve,
	oacute: oacute,
	ocirc: ocirc,
	otilde: otilde,
	ouml: ouml,
	divide: divide,
	oslash: oslash,
	ugrave: ugrave,
	uacute: uacute,
	ucirc: ucirc,
	uuml: uuml,
	yacute: yacute,
	thorn: thorn,
	yuml: yuml,
	OElig: OElig,
	oelig: oelig,
	Scaron: Scaron,
	scaron: scaron,
	Yuml: Yuml,
	fnof: fnof,
	circ: circ,
	tilde: tilde,
	Alpha: Alpha,
	Beta: Beta,
	Gamma: Gamma,
	Delta: Delta,
	Epsilon: Epsilon,
	Zeta: Zeta,
	Eta: Eta,
	Theta: Theta,
	Iota: Iota,
	Kappa: Kappa,
	Lambda: Lambda,
	Mu: Mu,
	Nu: Nu,
	Xi: Xi,
	Omicron: Omicron,
	Pi: Pi,
	Rho: Rho,
	Sigma: Sigma,
	Tau: Tau,
	Upsilon: Upsilon,
	Phi: Phi,
	Chi: Chi,
	Psi: Psi,
	Omega: Omega,
	alpha: alpha,
	beta: beta,
	gamma: gamma,
	delta: delta,
	epsilon: epsilon,
	zeta: zeta,
	eta: eta,
	theta: theta,
	iota: iota,
	kappa: kappa,
	lambda: lambda,
	mu: mu,
	nu: nu,
	xi: xi,
	omicron: omicron,
	pi: pi,
	rho: rho,
	sigmaf: sigmaf,
	sigma: sigma,
	tau: tau,
	upsilon: upsilon,
	phi: phi,
	chi: chi,
	psi: psi,
	omega: omega,
	thetasym: thetasym,
	upsih: upsih,
	piv: piv,
	ensp: ensp,
	emsp: emsp,
	thinsp: thinsp,
	zwnj: zwnj,
	zwj: zwj,
	lrm: lrm,
	rlm: rlm,
	ndash: ndash,
	mdash: mdash,
	lsquo: lsquo,
	rsquo: rsquo,
	sbquo: sbquo,
	ldquo: ldquo,
	rdquo: rdquo,
	bdquo: bdquo,
	dagger: dagger,
	Dagger: Dagger,
	bull: bull,
	hellip: hellip,
	permil: permil,
	prime: prime,
	Prime: Prime,
	lsaquo: lsaquo,
	rsaquo: rsaquo,
	oline: oline,
	frasl: frasl,
	euro: euro,
	image: image,
	weierp: weierp,
	real: real,
	trade: trade,
	alefsym: alefsym,
	larr: larr,
	uarr: uarr,
	rarr: rarr,
	darr: darr,
	harr: harr,
	crarr: crarr,
	lArr: lArr,
	uArr: uArr,
	rArr: rArr,
	dArr: dArr,
	hArr: hArr,
	forall: forall,
	part: part,
	exist: exist,
	empty: empty,
	nabla: nabla,
	isin: isin,
	notin: notin,
	ni: ni,
	prod: prod,
	sum: sum,
	minus: minus,
	lowast: lowast,
	radic: radic,
	prop: prop,
	infin: infin,
	ang: ang,
	and: and,
	or: or,
	cap: cap,
	cup: cup,
	int: int,
	there4: there4,
	sim: sim,
	cong: cong,
	asymp: asymp,
	ne: ne,
	equiv: equiv,
	le: le,
	ge: ge,
	sub: sub,
	sup: sup,
	nsub: nsub,
	sube: sube,
	supe: supe,
	oplus: oplus,
	otimes: otimes,
	perp: perp,
	sdot: sdot,
	lceil: lceil,
	rceil: rceil,
	lfloor: lfloor,
	rfloor: rfloor,
	lang: lang,
	rang: rang,
	loz: loz,
	spades: spades,
	clubs: clubs,
	hearts: hearts,
	diams: diams
};

const HTMLEntityRe = /&(\S+);/g;
const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;

/**
 * Encode unicode hex html entities like for example &#x222;
 * @param   {string} string - input string
 * @returns {string} encoded string
 */
function encodeHex(string) {
  const hex = string.substr(2);

  return HEX_NUMBER.test(hex) ? String.fromCodePoint(parseInt(hex, 16)) : string
}

/**
 * Encode unicode decimal html entities like for example &#222;
 * @param   {string} string - input string
 * @returns {string} encoded string
 */
function encodeDecimal(string) {
  const nr = string.substr(1);

  return DECIMAL_NUMBER.test(nr)
    ? String.fromCodePoint(parseInt(nr, 10))
    : string
}

/**
 * Encode html entities in strings like &nbsp;
 * @param   {string} string - input string
 * @returns {string} encoded string
 */
function encodeHTMLEntities(string) {
  return string.replace(HTMLEntityRe, (match, entity) => {
    const [firstChar, secondChar] = entity;

    if (firstChar === '#') {
      return secondChar === 'x' ? encodeHex(entity) : encodeDecimal(entity)
    } else {
      return entities[entity] || entity
    }
  })
}

/**
 * Native String.prototype.trimEnd method with fallback to String.prototype.trimRight
 * Edge doesn't support the first one
 * @param   {string} string - input string
 * @returns {string} trimmed output
 */
function trimEnd(string) {
  return (string.trimEnd || string.trimRight).apply(string)
}

/**
 * Native String.prototype.trimStart method with fallback to String.prototype.trimLeft
 * Edge doesn't support the first one
 * @param   {string} string - input string
 * @returns {string} trimmed output
 */
function trimStart(string) {
  return (string.trimStart || string.trimLeft).apply(string)
}

/**
 * Unescape the user escaped chars
 * @param   {string} string - input string
 * @param   {string} char - probably a '{' or anything the user want's to escape
 * @returns {string} cleaned up string
 */
function unescapeChar(string, char) {
  return string.replace(RegExp(`\\\\${char}`, 'gm'), char)
}

/**
 * Generate the pure immutable string chunks from a RiotParser.Node.Text
 * @param   {RiotParser.Node.Text} node - riot parser text node
 * @param   {string} sourceCode sourceCode - source code
 * @returns {Array} array containing the immutable string chunks
 */
function generateLiteralStringChunksFromNode(node, sourceCode) {
  return (
    node.expressions
      .reduce((chunks, expression, index) => {
        const start = index ? node.expressions[index - 1].end : node.start;
        const string = encodeHTMLEntities(
          sourceCode.substring(start, expression.start),
        );

        // trimStart the first string
        chunks.push(index === 0 ? trimStart(string) : string);

        // add the tail to the string
        if (index === node.expressions.length - 1)
          chunks.push(
            encodeHTMLEntities(
              trimEnd(sourceCode.substring(expression.end, node.end)),
            ),
          );

        return chunks
      }, [])
      // comments are not supported here
      .filter((str) => !isCommentString(str))
      .map((str) => (node.unescape ? unescapeChar(str, node.unescape) : str))
  )
}

/**
 * Simple bindings might contain multiple expressions like for example: "{foo} and {bar}"
 * This helper aims to merge them in a template literal if it's necessary
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns { Object } a template literal expression object
 */
function mergeNodeExpressions(node, sourceFile, sourceCode) {
  if (node.parts.length === 1)
    return transformExpression(node.expressions[0], sourceFile, sourceCode)

  const pureStringChunks = generateLiteralStringChunksFromNode(node, sourceCode);
  const stringsArray = pureStringChunks
    .reduce((acc, str, index) => {
      const expr = node.expressions[index];

      return [
        ...acc,
        builders.literal(str),
        expr ? transformExpression(expr, sourceFile, sourceCode) : nullNode(),
      ]
    }, [])
    // filter the empty literal expressions
    .filter((expr) => !isLiteral(expr) || expr.value);

  return createArrayString(stringsArray)
}

/**
 * Create a text expression
 * @param   {RiotParser.Node.Text} sourceNode - text node to parse
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {number} childNodeIndex - position of the child text node in its parent children nodes
 * @returns {AST.Node} object containing the expression binding keys
 */
function createTextExpression(
  sourceNode,
  sourceFile,
  sourceCode,
  childNodeIndex,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(TEXT_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_CHILD_NODE_INDEX_KEY,
      builders.literal(childNodeIndex),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      wrapASTInFunctionWithScope(
        mergeNodeExpressions(sourceNode, sourceFile, sourceCode),
      ),
    ),
  ])
}

function createValueExpression(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(VALUE_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

function createRefExpression(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(EXPRESSION_TYPES),
        builders.identifier(REF_EXPRESSION_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createAttributeEvaluationFunction(sourceNode, sourceFile, sourceCode),
    ),
  ])
}

function createExpression(
  sourceNode,
  sourceFile,
  sourceCode,
  childNodeIndex,
  parentNode,
) {
  switch (true) {
    case isTextNode(sourceNode):
      return createTextExpression(sourceNode, sourceFile, sourceCode, childNodeIndex)
    // progress nodes value attributes will be rendered as attributes
    // see https://github.com/riot/compiler/issues/122
    case isValueAttribute(sourceNode) &&
      domNodes.hasValueAttribute(parentNode.name) &&
      !isProgressNode(parentNode):
      return createValueExpression(sourceNode, sourceFile, sourceCode)
    case isRefAttribute(sourceNode):
      return createRefExpression(sourceNode, sourceFile, sourceCode)
    case isEventAttribute(sourceNode):
      return createEventExpression(sourceNode, sourceFile, sourceCode)
    default:
      return createAttributeExpression(sourceNode, parentNode, sourceFile, sourceCode)
  }
}

/**
 * Create the attribute expressions
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {Array} array containing all the attribute expressions
 */
function createAttributeExpressions(sourceNode, sourceFile, sourceCode) {
  return findDynamicAttributes(sourceNode).map((attribute) =>
    createExpression(attribute, sourceFile, sourceCode, 0, sourceNode),
  )
}

/**
 * Parse a js source to generate the AST
 * @param   {string} source - javascript source
 * @param   {Object} options - parser options
 * @returns {AST} AST tree
 */
function generateAST(source, options) {
  return recast.parse(source, {
    parser: {
      parse: (source, opts) =>
        typescript_js.parse(source, {
          ...opts,
          ecmaVersion: 'latest',
        }),
    },
    ...options,
  })
}

const scope = builders.identifier(SCOPE);
const getName = (node) => (node && node.name ? node.name : node);

/**
 * Replace the path scope with a member Expression
 * @param   { types.NodePath } path - containing the current node visited
 * @param   { types.Node } property - node we want to prefix with the scope identifier
 * @returns {undefined} this is a void function
 */
function replacePathScope(path, property) {
  // make sure that for the scope injection the extra parenthesis get removed
  removeExtraParenthesis(property);
  path.replace(builders.memberExpression(scope, property, false));
}

/**
 * Change the nodes scope adding the `scope` prefix
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean } return false if we want to stop the tree traversal
 * @context { types.visit }
 */
function updateNodeScope(path) {
  if (!isGlobal(path)) {
    replacePathScope(path, path.node);

    return false
  }

  this.traverse(path);
}

/**
 * Change the scope of the member expressions
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean } return always false because we want to check only the first node object
 */
function visitMemberExpression(path) {
  const traversePathObject = () => this.traverse(path.get('object'));
  const currentObject = path.node.object;

  switch (true) {
    case isGlobal(path):
      if (currentObject.arguments && currentObject.arguments.length) {
        traversePathObject();
      }
      break
    case !path.value.computed && isIdentifier(currentObject):
      replacePathScope(path, path.node);
      break
    default:
      this.traverse(path);
  }

  return false
}

/**
 * Objects properties should be handled a bit differently from the Identifier
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean } return false if we want to stop the tree traversal
 */
function visitObjectProperty(path) {
  const value = path.node.value;
  const isShorthand = path.node.shorthand;

  if (isIdentifier(value) || isMemberExpression(value) || isShorthand) {
    // disable shorthand object properties
    if (isShorthand) path.node.shorthand = false;

    updateNodeScope.call(this, path.get('value'));
  } else {
    this.traverse(path.get('value'));
  }

  return false
}

/**
 * The this expressions should be replaced with the scope
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean|undefined } return false if we want to stop the tree traversal
 */
function visitThisExpression(path) {
  path.replace(scope);
  this.traverse(path);

  return false
}

/**
 * Replace the identifiers with the node scope
 * @param   { types.NodePath } path - containing the current node visited
 * @returns { boolean|undefined } return false if we want to stop the tree traversal
 */
function visitIdentifier(path) {
  const parentValue = path.parent.value;

  if (
    (!isMemberExpression(parentValue) &&
      // Esprima seem to behave differently from the default recast ast parser
      // fix for https://github.com/riot/riot/issues/2983
      parentValue.key !== path.node) ||
    parentValue.computed
  ) {
    updateNodeScope.call(this, path);
  }

  return false
}

/**
 * Update the scope of the global nodes
 * @param   { Object } ast - ast program
 * @returns { Object } the ast program with all the global nodes updated
 */
function updateNodesScope(ast) {
  const ignorePath = () => false;

  types.visit(ast, {
    visitIdentifier,
    visitMemberExpression,
    visitObjectProperty,
    visitThisExpression,
    visitClassExpression: ignorePath,
  });

  return ast
}

/**
 * Convert any expression to an AST tree
 * @param   { Object } expression - expression parsed by the riot parser
 * @param   { string } sourceFile - original tag file
 * @param   { string } sourceCode - original tag source code
 * @returns { Object } the ast generated
 */
function createASTFromExpression(expression, sourceFile, sourceCode) {
  const code = sourceFile
    ? addLineOffset(expression.text, sourceCode, expression)
    : expression.text;

  return generateAST(`(${code})`, {
    sourceFileName: sourceFile,
  })
}

/**
 * Create the bindings template property
 * @param   {Array} args - arguments to pass to the template function
 * @returns {ASTNode} a binding template key
 */
function createTemplateProperty(args) {
  return simplePropertyNode(
    BINDING_TEMPLATE_KEY,
    args ? callTemplateFunction(...args) : nullNode(),
  )
}

/**
 * Try to get the expression of an attribute node
 * @param   { RiotParser.Node.Attribute } attribute - riot parser attribute node
 * @returns { RiotParser.Node.Expression } attribute expression value
 */
function getAttributeExpression(attribute) {
  return attribute.expressions
    ? attribute.expressions[0]
    : {
        // if no expression was found try to typecast the attribute value
        ...attribute,
        text: attribute.value,
      }
}

/**
 * Wrap the ast generated in a function call providing the scope argument
 * @param   {Object} ast - function body
 * @returns {FunctionExpresion} function having the scope argument injected
 */
function wrapASTInFunctionWithScope(ast) {
  const fn = builders.arrowFunctionExpression([scope], ast);

  // object expressions need to be wrapped in parentheses
  // recast doesn't allow it
  // see also https://github.com/benjamn/recast/issues/985
  if (isObjectExpression(ast)) {
    // doing a small hack here
    // trying to figure out how the recast printer works internally
    ast.extra = {
      parenthesized: true,
    };
  }

  return fn
}

/**
 * Convert any parser option to a valid template one
 * @param   { RiotParser.Node.Expression } expression - expression parsed by the riot parser
 * @param   { string } sourceFile - original tag file
 * @param   { string } sourceCode - original tag source code
 * @returns { Object } a FunctionExpression object
 *
 * @example
 *  toScopedFunction('foo + bar') // scope.foo + scope.bar
 *
 * @example
 *  toScopedFunction('foo.baz + bar') // scope.foo.baz + scope.bar
 */
function toScopedFunction(expression, sourceFile, sourceCode) {
  return compose__default.default(wrapASTInFunctionWithScope, transformExpression)(
    expression,
    sourceFile,
    sourceCode,
  )
}

/**
 * Transform an expression node updating its global scope
 * @param   {RiotParser.Node.Expr} expression - riot parser expression node
 * @param   {string} sourceFile - source file
 * @param   {string} sourceCode - source code
 * @returns {ASTExpression} ast expression generated from the riot parser expression node
 */
function transformExpression(expression, sourceFile, sourceCode) {
  return compose__default.default(
    removeExtraParenthesis,
    getExpressionAST,
    updateNodesScope,
    createASTFromExpression,
  )(expression, sourceFile, sourceCode)
}

/**
 * Remove the extra parents from the compiler generated expressions
 * @param  {AST.Expression} expr - ast expression
 * @returns {AST.Expression} program expression output without parenthesis
 */
function removeExtraParenthesis(expr) {
  if (expr.extra) expr.extra.parenthesized = false;

  return expr
}

/**
 * Get the parsed AST expression of riot expression node
 * @param   {AST.Program} sourceAST - raw node parsed
 * @returns {AST.Expression} program expression output
 */
function getExpressionAST(sourceAST) {
  const astBody = sourceAST.program.body;

  return astBody[0] ? astBody[0].expression : astBody
}

/**
 * Create the template call function
 * @param   {Array|string|Node.Literal} template - template string
 * @param   {Array<AST.Nodes>} bindings - template bindings provided as AST nodes
 * @returns {Node.CallExpression} template call expression
 */
function callTemplateFunction(template, bindings) {
  return builders.callExpression(builders.identifier(TEMPLATE_FN), [
    template ? builders.literal(template) : nullNode(),
    bindings ? builders.arrayExpression(bindings) : nullNode(),
  ])
}

/**
 * Create the template wrapper function injecting the dependencies needed to render the component html
 * @param {Array<AST.Nodes>|AST.BlockStatement} body - function body
 * @returns {AST.Node} arrow function expression
 */
const createTemplateDependenciesInjectionWrapper = (body) =>
  builders.arrowFunctionExpression(
    [TEMPLATE_FN, EXPRESSION_TYPES, BINDING_TYPES, GET_COMPONENT_FN].map(
      builders.identifier,
    ),
    body,
  );

/**
 * Convert any DOM attribute into a valid DOM selector useful for the querySelector API
 * @param   { string } attributeName - name of the attribute to query
 * @returns { string } the attribute transformed to a query selector
 */
const attributeNameToDOMQuerySelector = (attributeName) =>
  `[${attributeName}]`;

/**
 * Create the properties to query a DOM node
 * @param   { string } attributeName - attribute name needed to identify a DOM node
 * @returns { Array<AST.Node> } array containing the selector properties needed for the binding
 */
function createSelectorProperties(attributeName) {
  return attributeName
    ? [
        simplePropertyNode(
          BINDING_REDUNDANT_ATTRIBUTE_KEY,
          builders.literal(attributeName),
        ),
        simplePropertyNode(
          BINDING_SELECTOR_KEY,
          compose__default.default(
            builders.literal,
            attributeNameToDOMQuerySelector,
          )(attributeName),
        ),
      ]
    : []
}

/**
 * Clone the node filtering out the selector attribute from the attributes list
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} selectorAttribute - name of the selector attribute to filter out
 * @returns {RiotParser.Node} the node with the attribute cleaned up
 */
function cloneNodeWithoutSelectorAttribute(node, selectorAttribute) {
  return {
    ...node,
    attributes: getAttributesWithoutSelector(
      getNodeAttributes(node),
      selectorAttribute,
    ),
  }
}

/**
 * Get the node attributes without the selector one
 * @param   {Array<RiotParser.Attr>} attributes - attributes list
 * @param   {string} selectorAttribute - name of the selector attribute to filter out
 * @returns {Array<RiotParser.Attr>} filtered attributes
 */
function getAttributesWithoutSelector(attributes, selectorAttribute) {
  if (selectorAttribute)
    return attributes.filter(
      (attribute) => attribute.name !== selectorAttribute,
    )

  return attributes
}

/**
 * Clean binding or custom attributes
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array<RiotParser.Node.Attr>} only the attributes that are not bindings or directives
 */
function cleanAttributes(node) {
  return getNodeAttributes(node).filter(
    (attribute) =>
      ![
        IF_DIRECTIVE,
        EACH_DIRECTIVE,
        KEY_ATTRIBUTE,
        SLOT_ATTRIBUTE,
        IS_DIRECTIVE,
      ].includes(attribute.name),
  )
}

/**
 * Root node factory function needed for the top root nodes and the nested ones
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {RiotParser.Node} root node
 */
function rootNodeFactory(node) {
  return {
    nodes: getChildrenNodes(node),
    isRoot: true,
  }
}

/**
 * Create a root node proxing only its nodes and attributes
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {RiotParser.Node} root node
 */
function createRootNode(node) {
  return {
    ...rootNodeFactory(node),
    attributes: compose__default.default(
      // root nodes should always have attribute expressions
      transformStaticAttributesIntoExpressions,
      // root nodes shouldn't have directives
      cleanAttributes,
    )(node),
  }
}

/**
 * Create nested root node. Each and If directives create nested root nodes for example
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {RiotParser.Node} root node
 */
function createNestedRootNode(node) {
  return {
    ...rootNodeFactory(node),
    isNestedRoot: true,
    attributes: cleanAttributes(node),
  }
}

/**
 * Transform the static node attributes into expressions, useful for the root nodes
 * @param   {Array<RiotParser.Node.Attr>} attributes - riot parser node
 * @returns {Array<RiotParser.Node.Attr>} all the attributes received as attribute expressions
 */
function transformStaticAttributesIntoExpressions(attributes) {
  return attributes.map((attribute) => {
    if (attribute.expressions) return attribute

    return {
      ...attribute,
      expressions: [
        {
          start: attribute.valueStart,
          end: attribute.end,
          text: `'${
            attribute.value
              ? attribute.value
              : // boolean attributes should be treated differently
                attribute[IS_BOOLEAN_ATTRIBUTE]
                ? attribute.name
                : ''
          }'`,
        },
      ],
    }
  })
}

/**
 * Get all the child nodes of a RiotParser.Node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array<RiotParser.Node>} all the child nodes found
 */
function getChildrenNodes(node) {
  return node && node.nodes ? node.nodes : []
}

/**
 * Get all the attributes of a riot parser node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {Array<RiotParser.Node.Attribute>} all the attributes find
 */
function getNodeAttributes(node) {
  return node.attributes ? node.attributes : []
}

/**
 * Create custom tag name function
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns {RiotParser.Node.Attr} the node name as expression attribute
 */
function createCustomNodeNameEvaluationFunction(
  node,
  sourceFile,
  sourceCode,
) {
  const isAttribute = findIsAttribute(node);
  const toRawString = (val) => `'${val}'`;

  if (isAttribute) {
    return isAttribute.expressions
      ? wrapASTInFunctionWithScope(
          mergeAttributeExpressions(isAttribute, sourceFile, sourceCode),
        )
      : toScopedFunction(
          {
            ...isAttribute,
            text: toRawString(isAttribute.value),
          },
          sourceFile,
          sourceCode,
        )
  }

  return toScopedFunction(
    { ...node, text: toRawString(getName(node)) },
    sourceFile,
    sourceCode,
  )
}

/**
 * Convert all the node static attributes to strings
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {string} all the node static concatenated as string
 */
function staticAttributesToString(node) {
  return findStaticAttributes(node)
    .map((attribute) =>
      attribute[IS_BOOLEAN_ATTRIBUTE] || !attribute.value
        ? attribute.name
        : `${attribute.name}="${unescapeNode(attribute, 'value').value}"`,
    )
    .join(' ')
}

/**
 * Make sure that node escaped chars will be unescaped
 * @param   {RiotParser.Node} node - riot parser node
 * @param   {string} key - key property to unescape
 * @returns {RiotParser.Node} node with the text property unescaped
 */
function unescapeNode(node, key) {
  if (node.unescape) {
    return {
      ...node,
      [key]: unescapeChar(node[key], node.unescape),
    }
  }

  return node
}

/**
 * Convert a riot parser opening node into a string
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {string} the node as string
 */
function nodeToString(node) {
  const attributes = staticAttributesToString(node);

  switch (true) {
    case isTagNode(node):
      return `<${node.name}${attributes ? ` ${attributes}` : ''}${
        isVoidNode(node) ? '/' : ''
      }>`
    case isTextNode(node):
      return hasExpressions(node)
        ? TEXT_NODE_EXPRESSION_PLACEHOLDER
        : unescapeNode(node, 'text').text
    default:
      return node.text || ''
  }
}

/**
 * Close an html node
 * @param   {RiotParser.Node} node - riot parser node
 * @returns {string} the closing tag of the html tag node passed to this function
 */
function closeTag(node) {
  return node.name ? `</${node.name}>` : ''
}

/**
 * Create a strings array with the `join` call to transform it into a string
 * @param   {Array} stringsArray - array containing all the strings to concatenate
 * @returns {AST.CallExpression} array with a `join` call
 */
function createArrayString(stringsArray) {
  return builders.callExpression(
    builders.memberExpression(
      builders.arrayExpression(stringsArray),
      builders.identifier('join'),
      false,
    ),
    [builders.literal('')],
  )
}

/**
 * Simple expression bindings might contain multiple expressions like for example: "class="{foo} red {bar}""
 * This helper aims to merge them in a template literal if it's necessary
 * @param   {RiotParser.Attr} node - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns { Object } a template literal expression object
 */
function mergeAttributeExpressions(node, sourceFile, sourceCode) {
  if (!node.parts || node.parts.length === 1) {
    return transformExpression(node.expressions[0], sourceFile, sourceCode)
  }
  const stringsArray = [
    ...node.parts.reduce((acc, str) => {
      const expression = node.expressions.find((e) => e.text.trim() === str);

      return [
        ...acc,
        expression
          ? transformExpression(expression, sourceFile, sourceCode)
          : builders.literal(encodeHTMLEntities(str)),
      ]
    }, []),
  ].filter((expr) => !isLiteral(expr) || expr.value);

  return createArrayString(stringsArray)
}

/**
 * Create a selector that will be used to find the node via dom-bindings
 * @param   {number} id - temporary variable that will be increased anytime this function will be called
 * @returns {string} selector attribute needed to bind a riot expression
 */
const createBindingSelector = (function createSelector(id = 0) {
  return () => `${BINDING_SELECTOR_PREFIX}${id++}`
})();

/**
 * Create the AST array containing the attributes to bind to this node
 * @param   { RiotParser.Node.Tag } sourceNode - the custom tag
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns {AST.ArrayExpression} array containing the slot objects
 */
function createBindingAttributes(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  return builders.arrayExpression([
    ...compose__default.default(
      (attributes) =>
        attributes.map((attribute) =>
          createExpression(attribute, sourceFile, sourceCode, 0, sourceNode),
        ),
      (attributes) => attributes.filter(hasExpressions),
      (attributes) =>
        getAttributesWithoutSelector(attributes, selectorAttribute),
      cleanAttributes,
    )(sourceNode),
  ])
}

/**
 * Create an attribute evaluation function
 * @param   {RiotParser.Attr} sourceNode - riot parser node
 * @param   {string} sourceFile - original tag file
 * @param   {string} sourceCode - original tag source code
 * @returns { AST.Node } an AST function expression to evaluate the attribute value
 */
function createAttributeEvaluationFunction(
  sourceNode,
  sourceFile,
  sourceCode,
) {
  return wrapASTInFunctionWithScope(
    mergeAttributeExpressions(sourceNode, sourceFile, sourceCode),
  )
}

/**
 * Return a source map as JSON, it it has not the toJSON method it means it can
 * be used right the way
 * @param   { SourceMapGenerator|Object } map - a sourcemap generator or simply an json object
 * @returns { Object } the source map as JSON
 */
function sourcemapAsJSON(map) {
  if (map && map.toJSON) return map.toJSON()
  return map
}

/**
 * Compose two sourcemaps
 * @param   { SourceMapGenerator } formerMap - original sourcemap
 * @param   { SourceMapGenerator } latterMap - target sourcemap
 * @returns { Object } sourcemap json
 */
function composeSourcemaps(formerMap, latterMap) {
  if (checks.isNode() && formerMap && latterMap && latterMap.mappings) {
    return util_js.composeSourceMaps(sourcemapAsJSON(formerMap), sourcemapAsJSON(latterMap))
  } else if (checks.isNode() && formerMap) {
    return sourcemapAsJSON(formerMap)
  }

  return {}
}

/**
 * Create a new sourcemap generator
 * @param   { Object } options - sourcemap options
 * @returns { SourceMapGenerator } SourceMapGenerator instance
 */
function createSourcemap(options) {
  return new sourceMap.SourceMapGenerator(options)
}

const Output = Object.freeze({
  code: '',
  ast: [],
  meta: {},
  map: null,
});

/**
 * Create the right output data result of a parsing
 * @param   { Object } data - output data
 * @param   { string } data.code - code generated
 * @param   { AST } data.ast - ast representing the code
 * @param   { SourceMapGenerator } data.map - source map generated along with the code
 * @param   { Object } meta - compilation meta infomration
 * @returns { Output } output container object
 */
function createOutput(data, meta) {
  const output = {
    ...Output,
    ...data,
    meta,
  };

  if (!output.map && meta && meta.options && meta.options.file)
    return {
      ...output,
      map: createSourcemap({ file: meta.options.file }),
    }

  return output
}

/**
 * Transform the source code received via a compiler function
 * @param   { Function } compiler - function needed to generate the output code
 * @param   { Object } meta - compilation meta information
 * @param   { string } source - source code
 * @returns { Output } output - the result of the compiler
 */
function transform(compiler, meta, source) {
  const result = compiler ? compiler(source, meta) : { code: source };
  return createOutput(result, meta)
}

const postprocessors = new Set();

/**
 * Register a postprocessor that will be used after the parsing and compilation of the riot tags
 * @param { Function } postprocessor - transformer that will receive the output code ans sourcemap
 * @returns { Set } the postprocessors collection
 */
function register$1(postprocessor) {
  if (postprocessors.has(postprocessor)) {
    misc.panic(
      `This postprocessor "${
        postprocessor.name || postprocessor.toString()
      }" was already registered`,
    );
  }

  postprocessors.add(postprocessor);

  return postprocessors
}

/**
 * Exec all the postprocessors in sequence combining the sourcemaps generated
 * @param   { Output } compilerOutput - output generated by the compiler
 * @param   { Object } meta - compiling meta information
 * @returns { Output } object containing output code and source map
 */
function execute$1(compilerOutput, meta) {
  return Array.from(postprocessors).reduce(
    function (acc, postprocessor) {
      const { code, map } = acc;
      const output = postprocessor(code, meta);

      return {
        code: output.code,
        map: composeSourcemaps(map, output.map),
      }
    },
    createOutput(compilerOutput, meta),
  )
}

/**
 * Parsers that can be registered by users to preparse components fragments
 * @type { Object }
 */
const preprocessors = Object.freeze({
  javascript: new Map(),
  css: new Map(),
  template: new Map().set('default', (code) => ({ code })),
});

// throw a processor type error
function preprocessorTypeError(type) {
  misc.panic(
    `No preprocessor of type "${type}" was found, please make sure to use one of these: 'javascript', 'css' or 'template'`,
  );
}

// throw an error if the preprocessor was not registered
function preprocessorNameNotFoundError(name) {
  misc.panic(
    `No preprocessor named "${name}" was found, are you sure you have registered it?'`,
  );
}

/**
 * Register a custom preprocessor
 * @param   { string } type - preprocessor type either 'js', 'css' or 'template'
 * @param   { string } name - unique preprocessor id
 * @param   { Function } preprocessor - preprocessor function
 * @returns { Map } - the preprocessors map
 */
function register(type, name, preprocessor) {
  if (!type)
    misc.panic(
      "Please define the type of preprocessor you want to register 'javascript', 'css' or 'template'",
    );
  if (!name) misc.panic('Please define a name for your preprocessor');
  if (!preprocessor) misc.panic('Please provide a preprocessor function');
  if (!preprocessors[type]) preprocessorTypeError(type);
  if (preprocessors[type].has(name))
    misc.panic(`The preprocessor ${name} was already registered before`);

  preprocessors[type].set(name, preprocessor);

  return preprocessors
}

/**
 * Exec the compilation of a preprocessor
 * @param   { string } type - preprocessor type either 'js', 'css' or 'template'
 * @param   { string } name - unique preprocessor id
 * @param   { Object } meta - preprocessor meta information
 * @param   { string } source - source code
 * @returns { Output } object containing a sourcemap and a code string
 */
function execute(type, name, meta, source) {
  if (!preprocessors[type]) preprocessorTypeError(type);
  if (!preprocessors[type].has(name)) preprocessorNameNotFoundError(name);

  return transform(preprocessors[type].get(name), meta, source)
}

/**
 * Simple clone deep function, do not use it for classes or recursive objects!
 * @param   {*} source - possibily an object to clone
 * @returns {*} the object we wanted to clone
 */
function cloneDeep(source) {
  return JSON.parse(JSON.stringify(source))
}

/**
 * Generate the javascript from an ast source
 * @param   {AST} ast - ast object
 * @param   {Object} options - printer options
 * @returns {Object} code + map
 */
function generateJavascript(ast, options) {
  return recast.print(ast, {
    ...options,
    parser: {
      parse: (source, opts) =>
        typescript_js.parse(source, {
          ...opts,
          ecmaVersion: 'latest',
        }),
    },
    tabWidth: 2,
    wrapColumn: 0,
    quote: 'single',
  })
}

const getEachItemName = (expression) =>
  isSequenceExpression(expression.left)
    ? expression.left.expressions[0]
    : expression.left;
const getEachIndexName = (expression) =>
  isSequenceExpression(expression.left) ? expression.left.expressions[1] : null;
const getEachValue = (expression) => expression.right;
const nameToliteral = compose__default.default(builders.literal, getName);

const generateEachItemNameKey = (expression) =>
  simplePropertyNode(
    BINDING_ITEM_NAME_KEY,
    compose__default.default(nameToliteral, getEachItemName)(expression),
  );

const generateEachIndexNameKey = (expression) =>
  simplePropertyNode(
    BINDING_INDEX_NAME_KEY,
    compose__default.default(nameToliteral, getEachIndexName)(expression),
  );

const generateEachEvaluateKey = (
  expression,
  eachExpression,
  sourceFile,
  sourceCode,
) =>
  simplePropertyNode(
    BINDING_EVALUATE_KEY,
    compose__default.default(
      (e) => toScopedFunction(e, sourceFile, sourceCode),
      (e) => ({
        ...eachExpression,
        text: generateJavascript(e).code,
      }),
      getEachValue,
    )(expression),
  );

/**
 * Get the each expression properties to create properly the template binding
 * @param   { DomBinding.Expression } eachExpression - original each expression data
 * @param   { string } sourceFile - original tag file
 * @param   { string } sourceCode - original tag source code
 * @returns { Array } AST nodes that are needed to build an each binding
 */
function generateEachExpressionProperties(
  eachExpression,
  sourceFile,
  sourceCode,
) {
  const ast = createASTFromExpression(eachExpression, sourceFile, sourceCode);
  const body = ast.program.body;
  const firstNode = body[0];

  if (!isExpressionStatement(firstNode)) {
    misc.panic(
      `The each directives supported should be of type "ExpressionStatement",you have provided a "${firstNode.type}"`,
    );
  }

  const { expression } = firstNode;

  return [
    generateEachItemNameKey(expression),
    generateEachIndexNameKey(expression),
    generateEachEvaluateKey(expression, eachExpression, sourceFile, sourceCode),
  ]
}

/**
 * Transform a RiotParser.Node.Tag into an each binding
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the each attribute
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } an each binding node
 */
function createEachBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  const [ifAttribute, eachAttribute, keyAttribute] = [
    findIfAttribute,
    findEachAttribute,
    findKeyAttribute,
  ].map((f) => f(sourceNode));
  const attributeOrNull = (attribute) =>
    attribute
      ? toScopedFunction(
          getAttributeExpression(attribute),
          sourceFile,
          sourceCode,
        )
      : nullNode();

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(EACH_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(BINDING_GET_KEY_KEY, attributeOrNull(keyAttribute)),
    simplePropertyNode(BINDING_CONDITION_KEY, attributeOrNull(ifAttribute)),
    createTemplateProperty(
      createNestedBindings(
        sourceNode,
        sourceFile,
        sourceCode,
        selectorAttribute,
      ),
    ),
    ...createSelectorProperties(selectorAttribute),
    ...compose__default.default(
      generateEachExpressionProperties,
      getAttributeExpression,
    )(eachAttribute),
  ])
}

/**
 * Transform a RiotParser.Node.Tag into an if binding
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the if attribute
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { stiring } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } an if binding node
 */
function createIfBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  const ifAttribute = findIfAttribute(sourceNode);

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(IF_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      toScopedFunction(ifAttribute.expressions[0], sourceFile, sourceCode),
    ),
    ...createSelectorProperties(selectorAttribute),
    createTemplateProperty(
      createNestedBindings(
        sourceNode,
        sourceFile,
        sourceCode,
        selectorAttribute,
      ),
    ),
  ])
}

/**
 * Create the text node expressions
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {Array} array containing all the text node expressions
 */
function createTextNodeExpressions(sourceNode, sourceFile, sourceCode) {
  const childrenNodes = getChildrenNodes(sourceNode);

  return childrenNodes
    .filter(isTextNode)
    .filter(hasExpressions)
    .map((node) =>
      createExpression(
        node,
        sourceFile,
        sourceCode,
        childrenNodes.indexOf(node),
        sourceNode,
      ),
    )
}

/**
 * Add a simple binding to a riot parser node
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the if attribute
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } an each binding node
 */
function createSimpleBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    // root or removable nodes do not need selectors
    ...(isRemovableNode(sourceNode) || isRootNode(sourceNode)
      ? []
      : createSelectorProperties(selectorAttribute)),
    simplePropertyNode(
      BINDING_EXPRESSIONS_KEY,
      builders.arrayExpression([
        ...createTextNodeExpressions(sourceNode, sourceFile, sourceCode),
        ...createAttributeExpressions(sourceNode, sourceFile, sourceCode),
      ]),
    ),
  ])
}

/**
 * Transform a RiotParser.Node.Tag of type slot into a slot binding
 * @param   { RiotParser.Node.Tag } sourceNode - slot node
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } a slot binding node
 */
function createSlotBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  const slotNameAttribute = findAttribute(NAME_ATTRIBUTE, sourceNode);
  const slotName = slotNameAttribute
    ? slotNameAttribute.value
    : DEFAULT_SLOT_NAME;

  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(SLOT_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_ATTRIBUTES_KEY,
      createBindingAttributes(
        {
          ...sourceNode,
          // filter the name attribute
          attributes: getNodeAttributes(sourceNode).filter(
            (attribute) => getName(attribute) !== NAME_ATTRIBUTE,
          ),
        },
        selectorAttribute,
        sourceFile,
        sourceCode,
      ),
    ),
    simplePropertyNode(BINDING_NAME_KEY, builders.literal(slotName)),
    getChildrenNodes(sourceNode).length
      ? createTemplateProperty(
          createNestedBindings(
            // the root attributes should be removed
            { ...sourceNode, attributes: [] },
            sourceFile,
            sourceCode,
            selectorAttribute,
          ),
        )
      : simplePropertyNode(BINDING_TEMPLATE_KEY, builders.nullLiteral()),
    ...createSelectorProperties(selectorAttribute),
  ])
}

/**
 * Find the slots in the current component and group them under the same id
 * @param   {RiotParser.Node.Tag} sourceNode - the custom tag
 * @returns {Object} object containing all the slots grouped by name
 */
function groupSlots(sourceNode) {
  return getChildrenNodes(sourceNode).reduce(
    (acc, node) => {
      const slotAttribute = findSlotAttribute(node);

      if (slotAttribute) {
        acc[slotAttribute.value] = node;
      } else {
        acc.default = createNestedRootNode({
          nodes: [...getChildrenNodes(acc.default), node],
        });
      }

      return acc
    },
    {
      default: null,
    },
  )
}

/**
 * Create the slot entity to pass to the riot-dom bindings
 * @param   {string} id - slot id
 * @param   {RiotParser.Node.Tag} sourceNode - slot root node
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @returns {AST.Node} ast node containing the slot object properties
 */
function buildSlot(id, sourceNode, sourceFile, sourceCode) {
  const cloneNode = {
    ...sourceNode,
    attributes: getNodeAttributes(sourceNode),
  };

  // If the node is an empty slot we do not create the html key (https://github.com/riot/riot/issues/3055)
  const [html, bindings] =
    isSlotNode(cloneNode) && !hasChildrenNodes(cloneNode)
      ? [null, null]
      : build(cloneNode, sourceFile, sourceCode);

  return builders.objectExpression(
    [
      simplePropertyNode(BINDING_ID_KEY, builders.literal(id)),
      html
        ? simplePropertyNode(BINDING_HTML_KEY, builders.literal(html))
        : null,
      bindings
        ? simplePropertyNode(
            BINDING_BINDINGS_KEY,
            builders.arrayExpression(bindings),
          )
        : null,
    ].filter(Boolean),
  )
}

/**
 * Create the AST array containing the slots
 * @param   { RiotParser.Node.Tag } sourceNode - the custom tag
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns {AST.ArrayExpression} array containing the attributes to bind
 */
function createSlotsArray(sourceNode, sourceFile, sourceCode) {
  return builders.arrayExpression([
    ...compose__default.default(
      (slots) =>
        slots.map(([key, value]) =>
          buildSlot(key, value, sourceFile, sourceCode),
        ),
      (slots) => slots.filter(([, value]) => value),
      Object.entries,
      groupSlots,
    )(sourceNode),
  ])
}

/**
 * Find the slot attribute if it exists
 * @param   {RiotParser.Node.Tag} sourceNode - the custom tag
 * @returns {RiotParser.Node.Attr|undefined} the slot attribute found
 */
function findSlotAttribute(sourceNode) {
  return getNodeAttributes(sourceNode).find(
    (attribute) => attribute.name === SLOT_ATTRIBUTE,
  )
}

/**
 * Transform a RiotParser.Node.Tag into a tag binding
 * @param   { RiotParser.Node.Tag } sourceNode - the custom tag
 * @param   { string } selectorAttribute - attribute needed to select the target node
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns { AST.Node } tag binding node
 */
function createTagBinding(
  sourceNode,
  selectorAttribute,
  sourceFile,
  sourceCode,
) {
  return builders.objectExpression([
    simplePropertyNode(
      BINDING_TYPE_KEY,
      builders.memberExpression(
        builders.identifier(BINDING_TYPES),
        builders.identifier(TAG_BINDING_TYPE),
        false,
      ),
    ),
    simplePropertyNode(
      BINDING_GET_COMPONENT_KEY,
      builders.identifier(GET_COMPONENT_FN),
    ),
    simplePropertyNode(
      BINDING_EVALUATE_KEY,
      createCustomNodeNameEvaluationFunction(
        sourceNode,
        sourceFile,
        sourceCode,
      ),
    ),
    simplePropertyNode(
      BINDING_SLOTS_KEY,
      createSlotsArray(sourceNode, sourceFile, sourceCode),
    ),
    simplePropertyNode(
      BINDING_ATTRIBUTES_KEY,
      createBindingAttributes(
        sourceNode,
        selectorAttribute,
        sourceFile,
        sourceCode,
      ),
    ),
    ...createSelectorProperties(selectorAttribute),
  ])
}

const BuildingState = Object.freeze({
  html: [],
  bindings: [],
  parent: null,
});

/**
 * Nodes having bindings should be cloned and new selector properties should be added to them
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} bindingsSelector - temporary string to identify the current node
 * @returns {RiotParser.Node} the original node parsed having the new binding selector attribute
 */
function createBindingsTag(sourceNode, bindingsSelector) {
  if (!bindingsSelector) return sourceNode

  return {
    ...sourceNode,
    // inject the selector bindings into the node attributes
    attributes: [
      {
        name: bindingsSelector,
        value: bindingsSelector,
      },
      ...getNodeAttributes(sourceNode),
    ],
  }
}

/**
 * Create a generic dynamic node (text or tag) and generate its bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and bindings for the current node
 */
function createDynamicNode(sourceNode, sourceFile, sourceCode, state) {
  switch (true) {
    case isTextNode(sourceNode):
      // text nodes will not have any bindings
      return [nodeToString(sourceNode), []]
    default:
      return createTagWithBindings(sourceNode, sourceFile, sourceCode)
  }
}

/**
 * Create only a dynamic tag node with generating a custom selector and its bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and bindings for the current node
 */
function createTagWithBindings(sourceNode, sourceFile, sourceCode) {
  const bindingsSelector = isRootNode(sourceNode)
    ? null
    : createBindingSelector();
  const cloneNode = createBindingsTag(sourceNode, bindingsSelector);
  const tagOpeningHTML = nodeToString(cloneNode);

  switch (true) {
    case hasEachAttribute(cloneNode):
      // EACH bindings have prio 1
      return [
        tagOpeningHTML,
        [createEachBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    case hasIfAttribute(cloneNode):
      // IF bindings have prio 2
      return [
        tagOpeningHTML,
        [createIfBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    case isCustomNode(cloneNode):
      // TAG bindings have prio 3
      return [
        tagOpeningHTML,
        [createTagBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    case isSlotNode(cloneNode):
      // slot tag
      return [
        tagOpeningHTML,
        [createSlotBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
    default:
      // this node has expressions bound to it
      return [
        tagOpeningHTML,
        [createSimpleBinding(cloneNode, bindingsSelector, sourceFile, sourceCode)],
      ]
  }
}

/**
 * Parse a node trying to extract its template and bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and bindings for the current node
 */
function parseNode(sourceNode, sourceFile, sourceCode, state) {
  // static nodes have no bindings
  if (isStaticNode(sourceNode)) return [nodeToString(sourceNode), []]
  return createDynamicNode(sourceNode, sourceFile, sourceCode)
}

/**
 * Create the tag binding
 * @param   { RiotParser.Node.Tag } sourceNode - tag containing the each attribute
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @param   { string } selector - binding selector
 * @returns { Array } array with only the tag binding AST
 */
function createNestedBindings(
  sourceNode,
  sourceFile,
  sourceCode,
  selector,
) {
  const mightBeARiotComponent = isCustomNode(sourceNode);
  const node = cloneNodeWithoutSelectorAttribute(sourceNode, selector);

  return mightBeARiotComponent
    ? [null, [createTagBinding(node, null, sourceFile, sourceCode)]]
    : build(createNestedRootNode(node), sourceFile, sourceCode)
}

/**
 * Build the template and the bindings
 * @param   {RiotParser.Node} sourceNode - any kind of node parsed via riot parser
 * @param   {string} sourceFile - source file path
 * @param   {string} sourceCode - original source
 * @param   {BuildingState} state - state representing the current building tree state during the recursion
 * @returns {Array} array containing the html output and the dom bindings
 */
function build(sourceNode, sourceFile, sourceCode, state) {
  if (!sourceNode)
    misc.panic(
      "Something went wrong with your tag DOM parsing, your tag template can't be created",
    );

  const [nodeHTML, nodeBindings] = parseNode(
    sourceNode,
    sourceFile,
    sourceCode);
  const childrenNodes = getChildrenNodes(sourceNode);
  const canRenderNodeHTML = isRemovableNode(sourceNode) === false;
  const currentState = { ...cloneDeep(BuildingState), ...state };

  // mutate the original arrays
  canRenderNodeHTML && currentState.html.push(...nodeHTML);
  currentState.bindings.push(...nodeBindings);

  // do recursion if
  // this tag has children and it has no special directives bound to it
  if (childrenNodes.length && !hasItsOwnTemplate(sourceNode)) {
    childrenNodes.forEach((node) =>
      build(node, sourceFile, sourceCode, {
        parent: sourceNode,
        ...currentState,
      }),
    );
  }

  // close the tag if it's not a void one
  if (canRenderNodeHTML && isTagNode(sourceNode) && !isVoidNode(sourceNode)) {
    currentState.html.push(closeTag(sourceNode));
  }

  return [currentState.html.join(''), currentState.bindings]
}

/* MAIN */
const TOKEN_TYPE = {
    SELECTOR: 1,
    BODY_START: 2,
    BODY_END: 3
};

/* MAIN */
const getIndexes = (str, substr) => {
    const indexes = [];
    const substrLength = substr.length;
    let indexFrom = 0;
    while (true) {
        const index = str.indexOf(substr, indexFrom);
        if (index === -1)
            return indexes;
        indexes.push(index);
        indexFrom = index + substrLength;
    }
};

/* IMPORT */
const { SELECTOR: SELECTOR$1, BODY_START: BODY_START$1, BODY_END: BODY_END$1 } = TOKEN_TYPE;
/* HELPERS */
const mergeTokensSorted = (t1, t2) => {
    let length = t1.length + t2.length;
    let i = t1.length - 1;
    let j = t2.length - 1;
    const merged = new Array(length);
    while (length > 0) {
        merged[--length] = (j < 0 || (i >= 0 && t1[i].index > t2[j].index)) ? t1[i--] : t2[j--];
    }
    return merged;
};
const mergeTokensSortedEvenOdd = (t1, t2) => {
    const length = t1.length;
    const merged = new Array(length * 2);
    for (let i = 0, j = 0; i < length; i++, j += 2) {
        merged[j] = t1[i];
        merged[j + 1] = t2[i];
    }
    return merged;
};
const findSelectorStartIndex = (tokens, tokenIndexStart = 0, limit) => {
    let lastIndex = 0;
    let lastTokenIndex = tokenIndexStart;
    for (let i = tokenIndexStart, l = tokens.length; i < l; i++) {
        const token = tokens[i];
        const index = token.index;
        if (index >= limit)
            break;
        lastIndex = (token.type === BODY_START$1) ? index : index + 1;
        lastTokenIndex = i + 1;
    }
    return [lastIndex, lastTokenIndex];
};
/* MAIN */
const tokenizer = (css) => {
    /* VARIABLES */
    const startIndexes = getIndexes(css, '{');
    const endIndexes = getIndexes(css, '}');
    const selectorTokens = new Array(startIndexes.length);
    const startTokens = new Array(startIndexes.length);
    const endTokens = new Array(endIndexes.length);
    let selectorIndex = 0;
    let startIndex = 0;
    let endIndex = 0;
    /* BODY_START */
    for (let i = 0, l = startIndexes.length; i < l; i++) {
        startTokens[startIndex++] = {
            type: BODY_START$1,
            index: startIndexes[i] + 1 // Start index
        };
    }
    /* BODY_END */
    for (let i = 0, l = endIndexes.length; i < l; i++) {
        endTokens[endIndex++] = {
            type: BODY_END$1,
            index: endIndexes[i] // End index
        };
    }
    /* SELECTOR */
    let prevStartTokenIndex = 0;
    let prevEndTokenIndex = 0;
    for (let i = 0, l = startIndexes.length; i < l; i++) {
        const indexEnd = startIndexes[i];
        const findStartData = findSelectorStartIndex(startTokens, prevStartTokenIndex, indexEnd);
        const findEndData = findSelectorStartIndex(endTokens, prevEndTokenIndex, indexEnd);
        prevStartTokenIndex = findStartData[1];
        prevEndTokenIndex = findEndData[1];
        let index = (findStartData[0] >= findEndData[0]) ? findStartData[0] : findEndData[0];
        let selector = css.slice(index, indexEnd);
        let semicolonIndex = index + selector.lastIndexOf(';', indexEnd) + 1;
        if (semicolonIndex > index) {
            index = semicolonIndex;
            selector = css.slice(index, indexEnd);
        }
        selectorTokens[selectorIndex++] = {
            type: SELECTOR$1,
            index,
            indexEnd,
            selector
        };
    }
    /* RETURN */
    return mergeTokensSorted(mergeTokensSortedEvenOdd(selectorTokens, startTokens), endTokens);
};

/* IMPORT */
const { SELECTOR, BODY_START, BODY_END } = TOKEN_TYPE;
/* HELPERS */
const getNodeBody = (node, css) => {
    const { children } = node;
    let body = '';
    let start = node.bodyIndex;
    for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        body += css.slice(start, child.index);
        start = child.indexEnd + 1;
    }
    body += css.slice(start, node.bodyIndexEnd);
    return body;
};
/* MAIN */
const parse = (css) => {
    const tokens = tokenizer(css);
    const AST = { parent: null, children: [] };
    let parent = AST;
    let index = 0;
    while (true) {
        if (!parent)
            throw new Error('Parent node not found');
        const token = tokens[index];
        if (!token)
            break;
        if (token.type === SELECTOR) {
            const tokenBodyStart = tokens[index + 1];
            if (!tokenBodyStart || tokenBodyStart.type !== BODY_START)
                throw new Error('Found "selector" token without expected subsequent "body_start" token');
            const node = {
                parent,
                index: token.index,
                indexEnd: -1,
                selector: token.selector,
                selectorIndex: token.index,
                selectorIndexEnd: token.indexEnd,
                body: '',
                bodyIndex: tokenBodyStart.index,
                bodyIndexEnd: -1,
                children: []
            };
            parent.children.push(node);
            parent = node;
            index += 2;
        }
        else if (token.type === BODY_END) {
            const node = parent; //TSC
            node.indexEnd = token.index + 1;
            node.bodyIndexEnd = token.index;
            node.body = getNodeBody(node, css);
            parent = node.parent;
            index += 1;
        }
        else {
            throw new Error(`Unexpected token of type: "${token.type}"`);
        }
    }
    return AST;
};

/* IMPORT */
/* HELPERS */
const stringifyNode = (node) => {
    return `${node.selector}{${node.body}${stringifyChildren(node.children)}}`;
};
const stringifyChildren = (children) => {
    let css = '';
    for (let i = 0, l = children.length; i < l; i++) {
        css += stringifyNode(children[i]);
    }
    return css;
};
/* MAIN */
const stringify = (ast) => {
    return stringifyChildren(ast.children);
};

/* IMPORT */
/* MAIN */
const traverse$1 = (ast, fn) => {
    const { children } = ast;
    for (let i = 0, l = children.length; i < l; i++) {
        const node = children[i];
        fn(node);
        traverse$1(node, fn);
    }
};

/* IMPORT */
/* MAIN */
const Parser = { parse, stringify, traverse: traverse$1 };

const ATTRIBUTE_TYPE_NAME = 'type';

/**
 * Get the type attribute from a node generated by the riot parser
 * @param   { Object} sourceNode - riot parser node
 * @returns { string|null } a valid type to identify the preprocessor to use or nothing
 */
function getPreprocessorTypeByAttribute(sourceNode) {
  const typeAttribute = sourceNode.attributes
    ? sourceNode.attributes.find(
        (attribute) => attribute.name === ATTRIBUTE_TYPE_NAME,
      )
    : null;

  return typeAttribute ? normalize(typeAttribute.value) : null
}

/**
 * Remove the noise in case a user has defined the preprocessor type='text/scss'
 * @param   { string } value - input string
 * @returns { string } normalized string
 */
function normalize(value) {
  return value.replace('text/', '')
}

/**
 * Preprocess a riot parser node
 * @param   { string } preprocessorType - either css, js
 * @param   { string } preprocessorName - preprocessor id
 * @param   { Object } meta - compilation meta information
 * @param   { RiotParser.nodeTypes } node - css node detected by the parser
 * @returns { Output } code and sourcemap generated by the preprocessor
 */
function preprocess(
  preprocessorType,
  preprocessorName,
  meta,
  node,
) {
  const code = node.text;

  return preprocessorName
    ? execute(preprocessorType, preprocessorName, meta, code)
    : { code }
}

/**
 * Replace a text chunk in a range
 * @param {string} originalString - the text we need to patch
 * @param {number} start - the start offset where the string should be replaced
 * @param {number} end - the end where the string replacement should finish
 * @param {string} replacement - the string we need to insert
 * @return {string} the original text patched with the replacement string
 */
function replaceInRange(
  originalString,
  start,
  end,
  replacement,
) {
  return `${originalString.substring(0, start)}${replacement}${originalString.substring(end)}`
}

const HOST = ':host';
const DISABLED_SELECTORS = ['from', 'to'];

/**
 * Matches valid, multiline JavaScript comments in almost all its forms.
 * @const {RegExp}
 * @static
 */
const R_MLCOMMS = /\/\*[^*]*\*+(?:[^*/][^*]*\*+)*\//g;

/**
 * Matches the list of css selectors excluding the pseudo selectors
 * @const {RegExp}
 * @static
 */

const R_CSS_SELECTOR_LIST =
  /([^,]+)(?::(?!host)\w+(?:[\s|\S]*?\))?(?:[^,:]*)?)+|([^,]+)/g;

/**
 * Scope the css selectors prefixing them with the tag name
 * @param {string} tag - Tag name of the root element
 * @param {string} selectorList - list of selectors we need to scope
 * @returns {string} scoped selectors
 */
function addScopeToSelectorList(tag, selectorList) {
  return selectorList.replace(R_CSS_SELECTOR_LIST, (match, selector) => {
    const trimmedMatch = match.trim();
    const trimmedSelector = selector ? selector.trim() : trimmedMatch;
    // skip selectors already using the tag name
    if (trimmedSelector.indexOf(tag) === 0) {
      return match
    }

    // skips the keywords and percents of css animations
    if (
      !trimmedSelector ||
      DISABLED_SELECTORS.indexOf(trimmedSelector) > -1 ||
      trimmedSelector.slice(-1) === '%'
    ) {
      return match
    }

    // replace the `:host` pseudo-selector, where it is, with the root tag name;
    // if `:host` was not included, add the tag name as prefix, and mirror all `[is]`
    if (trimmedMatch.indexOf(HOST) < 0) {
      return `${tag} ${trimmedMatch},[is="${tag}"] ${trimmedMatch}`
    } else {
      return `${trimmedMatch.replace(HOST, tag)},${trimmedMatch.replace(
        HOST,
        `[is="${tag}"]`,
      )}`
    }
  })
}

/**
 * Traverse the ast children
 * @param {CSSParser.AST | CSSParser.NODE} ast - css parser node or ast
 * @param {Function} fn - function that is needed to parse the single nodes
 * @returns {CSSParser.AST | CSSParser.NODE} the original ast received
 */
const traverse = (ast, fn) => {
  const { children } = ast;

  children.forEach((child) => {
    // if fn returns false we stop the recursion
    if (fn(child) !== false) traverse(child, fn);
  });

  return ast
};

/**
 * Parses styles enclosed in a "scoped" tag
 * The "css" string is received without comments or surrounding spaces.
 *
 * @param   {string} tag - Tag name of the root element
 * @param   {string} css - The CSS code
 * @returns {string} CSS with the styles scoped to the root element
 */
function generateScopedCss(tag, css) {
  const ast = Parser.parse(css);
  const originalCssLength = css.length;

  traverse(ast, (node) => {
    // calculate the selector offset from the original css length
    const newSelectorOffset = css.length - originalCssLength;

    if (!node.selector.trim().startsWith('@')) {
      // the css parser doesn't detect the comments so we manually remove them
      const selector = node.selector.replace(R_MLCOMMS, '');

      // replace the selector and override the original css
      css = replaceInRange(
        css,
        node.selectorIndex + newSelectorOffset,
        node.selectorIndexEnd + newSelectorOffset,
        addScopeToSelectorList(tag, selector),
      );

      // stop the recursion
      return false
    }
  });

  return css
}

/**
 * Remove comments, compact and trim whitespace
 * @param { string } code - compiled css code
 * @returns { string } css code normalized
 */
function compactCss(code) {
  return code.replace(R_MLCOMMS, '').replace(/\s+/g, ' ').trim()
}

const escapeBackslashes = (s) => s.replace(/\\/g, '\\\\');
const escapeIdentifier = (identifier) =>
  escapeBackslashes(
    cssEscape__default.default(identifier, {
      isIdentifier: true,
    }),
  );

/**
 * Generate the component css
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } meta - compilation meta information
 * @param   { AST } ast - current AST output
 * @returns { AST } the AST generated
 */
function css(sourceNode, source, meta, ast) {
  const preprocessorName = getPreprocessorTypeByAttribute(sourceNode);
  const { options } = meta;
  const preprocessorOutput = preprocess(
    'css',
    preprocessorName,
    meta,
    sourceNode.text,
  );
  const normalizedCssCode = compactCss(preprocessorOutput.code);
  const escapedCssIdentifier = escapeIdentifier(meta.tagName);

  const cssCode = (
    options.scopedCss
      ? generateScopedCss(
          escapedCssIdentifier,
          escapeBackslashes(normalizedCssCode),
        )
      : escapeBackslashes(normalizedCssCode)
  ).trim();

  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === TAG_CSS_PROPERTY) {
        path.value.value = builders.templateLiteral(
          [builders.templateElement({ raw: cssCode, cooked: '' }, false)],
          [],
        );

        return false
      }

      this.traverse(path);
    },
  });

  return ast
}

/**
 * Ckeck if an Array-like object has empty length
 * @param {Array} target - Array-like object
 * @returns {boolean} target is empty or null
 */
function isEmptyArray(target) {
  return !target || !target.length
}

/**
 * True if the sourcemap has no mappings, it is empty
 * @param   {Object}  map - sourcemap json
 * @returns {boolean} true if empty
 */
function isEmptySourcemap(map) {
  return !map || isEmptyArray(map.mappings)
}

/**
 * Find the export default statement
 * @param   { Array } body - tree structure containing the program code
 * @returns { Object } node containing only the code of the export default statement
 */
function findExportDefaultStatement(body) {
  return body.find(isExportDefaultStatement)
}

/**
 * Find all import declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the import declarations detected
 */
function findAllImportDeclarations(body) {
  return body.filter(isImportDeclaration)
}

/**
 * Find all the named export declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the named export declarations detected
 */
function findAllExportNamedDeclarations(body) {
  return body.filter(isExportNamedDeclaration)
}

/**
 * Filter all the import declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the ast expressions without the import declarations
 */
function filterOutAllImportDeclarations(body) {
  return body.filter((n) => !isImportDeclaration(n))
}

/**
 * Filter all the export declarations
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the ast expressions without the export declarations
 */
function filterOutAllExportDeclarations(body) {
  return body.filter(
    (n) => !isExportNamedDeclaration(n) || isExportDefaultStatement(n),
  )
}

/**
 * Find the component interface exported
 * @param   { Array } body - tree structure containing the program code
 * @returns { Object|null } the object referencing the component interface if found
 */
function findComponentInterface(body) {
  const exportNamedDeclarations = body
    .filter(isExportNamedDeclaration)
    .map((n) => n.declaration);
  const types = exportNamedDeclarations.filter(isTypeAliasDeclaration);
  const interfaces = exportNamedDeclarations.filter(isInterfaceDeclaration);
  const isRiotComponentTypeName = ({ typeName }) =>
    typeName && typeName.name
      ? typeName.name === RIOT_TAG_INTERFACE_NAME
      : false;
  const extendsRiotComponent = ({ expression }) =>
    expression.name === RIOT_TAG_INTERFACE_NAME;

  return (
    types.find(
      (node) =>
        (node.typeAnnotation.types &&
          node.typeAnnotation.types.some(isRiotComponentTypeName)) ||
        isRiotComponentTypeName(node.typeAnnotation),
    ) ||
    interfaces.find(
      (node) => node.extends && node.extends.some(extendsRiotComponent),
    )
  )
}

/**
 * Add the component interface to the export declaration
 * @param   { Object } ast - ast object generated by recast
 * @param   { Object } componentInterface - the component typescript interface
 * @returns { Object } the component object exported combined with the riot typescript interfaces
 */
function addComponentInterfaceToExportedObject(ast, componentInterface) {
  const body = getProgramBody(ast);
  const RiotComponentWrapperImportSpecifier = builders.importSpecifier(
    builders.identifier(RIOT_INTERFACE_WRAPPER_NAME),
  );
  const componentInterfaceName = componentInterface.id.name;
  const riotImportDeclaration = findAllImportDeclarations(body).find(
    (node) => node.source.value === RIOT_MODULE_ID,
  );
  const exportDefaultStatement = body.find(isExportDefaultStatement);
  const objectExport = exportDefaultStatement.declaration;

  // add the RiotComponentWrapper to this component imports
  if (riotImportDeclaration) {
    riotImportDeclaration.specifiers.push(RiotComponentWrapperImportSpecifier);
  } else {
    // otherwise create the whole import statement from riot
    body.unshift(
      0,
      builders.importDeclaration(
        [RiotComponentWrapperImportSpecifier],
        builders.stringLiteral(RIOT_MODULE_ID),
      ),
    );
  }

  // override the object export adding the types detected
  exportDefaultStatement.declaration = builders.tsAsExpression(
    objectExport,
    builders.tsTypeReference(
      builders.identifier(RIOT_INTERFACE_WRAPPER_NAME),
      builders.tsTypeParameterInstantiation([
        builders.tsTypeReference(builders.identifier(componentInterfaceName)),
      ]),
    ),
  );

  return ast
}

/**
 * Create the default export declaration interpreting the old riot syntax relying on "this" statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Object } ExportDefaultDeclaration
 */
function createDefaultExportFromLegacySyntax(body) {
  return builders.exportDefaultDeclaration(
    builders.functionDeclaration(
      builders.identifier(TAG_LOGIC_PROPERTY),
      [],
      builders.blockStatement([
        ...compose__default.default(
          filterOutAllImportDeclarations,
          filterOutAllExportDeclarations,
        )(body),
        builders.returnStatement(builders.thisExpression()),
      ]),
    ),
  )
}

/**
 * Find all the code in an ast program except for the export default statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the program code except the export default expressions
 */
function filterNonExportDefaultStatements(body) {
  return body.filter(
    (node) =>
      !isExportDefaultStatement(node) && !isThisExpressionStatement(node),
  )
}

/**
 * Get the body of the AST structure
 * @param   { Object } ast - ast object generated by recast
 * @returns { Array } array containing the program code
 */
function getProgramBody(ast) {
  return ast.body || ast.program.body
}

/**
 * Extend the AST adding the new tag method containing our tag sourcecode
 * @param   { Object } ast - current output ast
 * @param   { Object } exportDefaultNode - tag export default node
 * @returns { Object } the output ast having the "tag" key extended with the content of the export default
 */
function extendTagProperty(ast, exportDefaultNode) {
  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === TAG_LOGIC_PROPERTY) {
        path.value.value = exportDefaultNode.declaration;
        return false
      }

      this.traverse(path);
    },
  });

  return ast
}

/**
 * Generate the component javascript logic
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } meta - compilation meta information
 * @param   { AST } ast - current AST output
 * @returns { AST } the AST generated
 */
function javascript(sourceNode, source, meta, ast) {
  const preprocessorName = getPreprocessorTypeByAttribute(sourceNode);
  const javascriptNode = addLineOffset(
    sourceNode.text.text,
    source,
    sourceNode,
  );
  const { options } = meta;
  const preprocessorOutput = preprocess('javascript', preprocessorName, meta, {
    ...sourceNode,
    text: javascriptNode,
  });
  const inputSourceMap = sourcemapAsJSON(preprocessorOutput.map);
  const generatedAst = generateAST(preprocessorOutput.code, {
    sourceFileName: options.file,
    inputSourceMap: isEmptySourcemap(inputSourceMap) ? null : inputSourceMap,
  });
  const generatedAstBody = getProgramBody(generatedAst);
  const exportDefaultNode = findExportDefaultStatement(generatedAstBody);
  const isLegacyRiotSyntax = checks.isNil(exportDefaultNode);
  const outputBody = getProgramBody(ast);
  const componentInterface = findComponentInterface(generatedAstBody);

  // throw in case of mixed component exports
  if (exportDefaultNode && generatedAstBody.some(isThisExpressionStatement))
    throw new Error(
      'You can\t use "export default {}" and root this statements in the same component',
    )

  // add to the ast the "private" javascript content of our tag script node
  outputBody.unshift(
    ...// for the legacy riot syntax we need to move all the import and (named) export statements outside of the function body
    (isLegacyRiotSyntax
      ? [
          ...findAllImportDeclarations(generatedAstBody),
          ...findAllExportNamedDeclarations(generatedAstBody),
        ]
      : // modern riot syntax will hoist all the private stuff outside of the export default statement
        filterNonExportDefaultStatements(generatedAstBody)),
  );

  // create the public component export properties from the root this statements
  if (isLegacyRiotSyntax)
    extendTagProperty(
      ast,
      createDefaultExportFromLegacySyntax(generatedAstBody),
    );

  // convert the export default adding its content to the component property exported
  if (exportDefaultNode) extendTagProperty(ast, exportDefaultNode);

  return componentInterface
    ? // add the component interface to the component object exported
      addComponentInterfaceToExportedObject(ast, componentInterface)
    : ast
}

/**
 * Create the content of the template function
 * @param   { RiotParser.Node } sourceNode - node generated by the riot compiler
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @returns {AST.BlockStatement} the content of the template function
 */
function createTemplateFunctionContent(sourceNode, sourceFile, sourceCode) {
  return callTemplateFunction(
    ...build(createRootNode(sourceNode), sourceFile, sourceCode),
  )
}

/**
 * Extend the AST adding the new template property containing our template call to render the component
 * @param   { Object } ast - current output ast
 * @param   { string } sourceFile - source file path
 * @param   { string } sourceCode - original source
 * @param   { RiotParser.Node } sourceNode - node generated by the riot compiler
 * @returns { Object } the output ast having the "template" key
 */
function extendTemplateProperty(ast, sourceFile, sourceCode, sourceNode) {
  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === TAG_TEMPLATE_PROPERTY) {
        path.value.value = createTemplateDependenciesInjectionWrapper(
          createTemplateFunctionContent(sourceNode, sourceFile, sourceCode),
        );

        return false
      }

      this.traverse(path);
    },
  });

  return ast
}

/**
 * Generate the component template logic
 * @param   { RiotParser.Node } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } meta - compilation meta information
 * @param   { AST } ast - current AST output
 * @returns { AST } the AST generated
 */
function template(sourceNode, source, meta, ast) {
  const { options } = meta;
  return extendTemplateProperty(ast, options.file, source, sourceNode)
}

/**
 * Find whether there is html code outside of the root node
 * @param   {RiotParser.Node} root - node generated by the riot compiler
 * @param   {string}  code - riot tag source code
 * @param   {Function} parse - riot parser function
 * @returns {boolean} true if extra markup is detected
 */
function hasHTMLOutsideRootNode(root, code, parse) {
  const additionalCode = root
    ? [
        // head
        code.substr(0, root.start),
        // tail
        code.substr(root.end, code.length),
      ]
        .join('')
        .trim()
    : '';

  if (additionalCode) {
    // if there are parsing errors we assume that there are no html
    // tags outside of the root node
    try {
      const { template, javascript, css } = parse(additionalCode).output;

      return [template, javascript, css].some(checks.isObject)
    } catch (error) {
      return false
    }
  }

  return false
}

/**
 * Get an object containing the template, css and javascript ast. The origianl source code and the sourcemap are also included
 *
 * @param { string | ParserResult } source - source code of the tag we will need to compile or a parsed Component AST
 * @param { Object } meta - compiler meta object that will be used to store the meta information of the input across the whole compilation
 * @returns { Object } object that will be used to generate the output code
 */
function preProcessSource(source, meta) {
  // if the source is a parser output we can return it directly
  // @link https://github.com/riot/compiler/issues/178
  if (util.isObject(source))
    return { ...source.output, code: source.data, map: null }

  const { options } = meta;

  const { code, map } = execute(
    'template',
    options.template,
    meta,
    source,
  );

  const parse = riotParser__default.default(options).parse;
  const { template, css, javascript } = parse(code).output;

  // see also https://github.com/riot/compiler/issues/130
  if (hasHTMLOutsideRootNode(template || css || javascript, source, parse)) {
    throw new Error('Multiple HTML root nodes are not supported')
  }

  return { template, css, javascript, map, code }
}

const DEFAULT_OPTIONS = {
  template: 'default',
  file: '[unknown-source-file]',
  scopedCss: true,
};

/**
 * Create the initial AST
 * @param {string} tagName - the name of the component we have compiled
 * @returns { AST } the initial AST
 *
 * @example
 * // the output represents the following string in AST
 */
function createInitialInput({ tagName }) {
  /*
  generates
  export default {
     ${TAG_CSS_PROPERTY}: null,
     ${TAG_LOGIC_PROPERTY}: null,
     ${TAG_TEMPLATE_PROPERTY}: null
  }
  */
  return builders.program([
    builders.exportDefaultDeclaration(
      builders.objectExpression([
        simplePropertyNode(TAG_CSS_PROPERTY, nullNode()),
        simplePropertyNode(TAG_LOGIC_PROPERTY, nullNode()),
        simplePropertyNode(TAG_TEMPLATE_PROPERTY, nullNode()),
        simplePropertyNode(TAG_NAME_PROPERTY, builders.literal(tagName)),
      ]),
    ),
  ])
}

/**
 * Make sure the input sourcemap is valid otherwise we ignore it
 * @param   {SourceMapGenerator} map - preprocessor source map
 * @returns {Object} sourcemap as json or nothing
 */
function normaliseInputSourceMap(map) {
  const inputSourceMap = sourcemapAsJSON(map);
  return isEmptySourcemap(inputSourceMap) ? null : inputSourceMap
}

/**
 * Override the sourcemap content making sure it will always contain the tag source code
 * @param   {Object} map - sourcemap as json
 * @param   {string} source - component source code
 * @returns {Object} original source map with the "sourcesContent" property overridden
 */
function overrideSourcemapContent(map, source) {
  return {
    ...map,
    sourcesContent: [source],
  }
}

/**
 * Create the compilation meta object
 * @param { string } source - source code of the tag we will need to compile
 * @param { string } options - compiling options
 * @returns {Object} meta object
 */
function createMeta(source, options) {
  return {
    tagName: null,
    fragments: null,
    options: {
      ...DEFAULT_OPTIONS,
      ...options,
    },
    source,
  }
}

/**
 * Parse a string to simply get its template AST
 * @param { string } source - string to parse
 * @param { Object } options - parser options
 * @returns {Object} riot parser template output
 */
const parseSimpleString = (source, options) => {
  const { parse } = riotParser__default.default(options);
  return parse(source).output.template
};

/**
 * Generate the component slots creation function from the root node
 * @param { string } source - component outer html
 * @param { Object } parserOptions - riot parser options
 * @returns { string } content of the function that can be used to crate the slots in runtime
 */
function generateSlotsFromString(source, parserOptions) {
  return compose__default.default(
    ({ code }) => code,
    generateJavascript,
    createTemplateDependenciesInjectionWrapper,
    createSlotsArray,
  )(parseSimpleString(source, parserOptions), DEFAULT_OPTIONS.file, source)
}

/**
 * Generate the Riot.js binding template function from a template string
 * @param { string } source - template string
 * @param { Object } parserOptions - riot parser options
 * @returns { string } Riot.js bindings template function generated
 */
function generateTemplateFunctionFromString(source, parserOptions) {
  return compose__default.default(
    ({ code }) => code,
    generateJavascript,
    callTemplateFunction,
  )(
    ...build(
      parseSimpleString(source, parserOptions),
      DEFAULT_OPTIONS.file,
      source,
    ),
  )
}

/**
 * Generate the output code source together with the sourcemap
 * @param { string | ParserResult } source - source code of the tag we will need to compile or a parsed Component AST
 * @param { Object } opts - compiling options
 * @returns { Output } object containing output code and source map
 */
function compile(source, opts = {}) {
  const meta = createMeta(source, opts);
  const { options } = meta;
  const { template: template$1, css: css$1, javascript: javascript$1, map, code } = preProcessSource(
    source,
    meta,
  );

  // extend the meta object with the result of the parsing
  Object.assign(meta, {
    tagName: template$1.name,
    fragments: { template: template$1, css: css$1, javascript: javascript$1 },
  });

  return compose__default.default(
    (result) => ({ ...result, meta }),
    (result) => execute$1(result, meta),
    (result) => ({
      ...result,
      map: overrideSourcemapContent(result.map, source),
    }),
    (ast) =>
      (meta.ast =
        ast &&
        generateJavascript(ast, {
          sourceMapName: `${options.file}.map`,
          inputSourceMap: normaliseInputSourceMap(map),
        })),
    hookGenerator(template, template$1, code, meta),
    hookGenerator(javascript, javascript$1, code, meta),
    hookGenerator(css, css$1, code, meta),
  )(createInitialInput(meta))
}

/**
 * Prepare the riot parser node transformers
 * @param   { Function } transformer - transformer function
 * @param   { Object } sourceNode - riot parser node
 * @param   { string } source - component source code
 * @param   { Object } meta - compilation meta information
 * @returns { function(): Promise<Output> } Function what resolves to object containing output code and source map
 */
function hookGenerator(transformer, sourceNode, source, meta) {
  const hasContent =
    sourceNode &&
    (sourceNode.text ||
      !isEmptyArray(sourceNode.nodes) ||
      !isEmptyArray(sourceNode.attributes));

  return hasContent
    ? curry__default.default(transformer)(sourceNode, source, meta)
    : (result) => result
}

// This function can be used to register new preprocessors
// a preprocessor can target either only the css or javascript nodes
// or the complete tag source file ('template')
const registerPreprocessor = register;

// This function can allow you to register postprocessors that will parse the output code
// here we can run prettifiers, eslint fixes...
const registerPostprocessor = register$1;

exports.compile = compile;
exports.createInitialInput = createInitialInput;
exports.generateSlotsFromString = generateSlotsFromString;
exports.generateTemplateFunctionFromString = generateTemplateFunctionFromString;
exports.registerPostprocessor = registerPostprocessor;
exports.registerPreprocessor = registerPreprocessor;
